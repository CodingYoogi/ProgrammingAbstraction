//  ProgAbstraction_ProgAssignTwo
//  Created by Rahul Sachdeva on 11/06/21.
#include <string>
#include <exception>
#include <cstdlib>
#include <iostream>
#include <fstream>
#include <ctype.h>

/*
 * File: genlib.h
 * Last modified on Sun Jul 17 2011 by Colin Leach
 *      modified on Mon Jun  8 20:16:05 2009 by eroberts
 *      modified on Wed Sep 18 13:41:31 2002 by zelenski
 * -----------------------------------------------------
 * This header file is indicated to be included in
 * all the programs written for CS106B/X and provides a few
 * common definitions. Note this header has a "using namespace std"
 * clause. If a file includes this header, it can then use
 * features from the std namespace without qualifying by scope.
 *
 * IMPORTANT!!  I had to change the interface after failing to
 * implement the Stanford version. Hence the genlib.h bundled
 * with CS106B exercises is NOT compatible - don't use it with
 * Colin's open-source library code.
 * Apologies for the inconvenience, but I'm a C++ novice doing
 * the best I can.
 */

//#ifndef _genlib_h
//#define _genlib_h

/* This strange-looking pragma is here to disable a warning from Visual C++
 * about truncating long identifiers for debugging symbols. The warning is
 * harmless, but a little disconcerting, so we suppress it. It comes up
 * using STL and other long template expansions.
 */

#if defined(_MSC_VER)
#pragma warning(disable: 4786)
#endif


using namespace std;

/*
 * Class: ErrorException
 * ---------------------
 * This exception is raised by calls to the Error function, which
 * makes it possible for clients to respond to error conditions
 * without having their programs bomb completely.
*/
class ErrorException : public exception {
public:
    ErrorException(string msg);
    virtual ~ErrorException() throw ();
    virtual const char* what() const throw ();
    //virtual string getMessage();
private:
    string msg;
};

/*
 * Function: Error
 * Usage: Error(msg);
 * ------------------
 * Error is used to signal an error condition in a program.  It first
 * throws an ErrorException.  If that isn't caught, it outputs the
 * error message string to the cerr stream and then exits the program
 * with a status code indicating failure.
 */

void Error(string str);

/* File : init.cpp
 * Last modified September 2011 by Colin
 * --------------------------------------------------
 * It is important NOT to include genlib.h here,
 * as that renames main() to Main()
 *
 * This function becomes the entry point for all student programs,
 * responsible for default handling of any ErrorException
 *
 * Limitation: note that this will fail if the student tries to
 * use command-line parameters with syntax
 *   int main(argc, char * argv[])
 */
int Main();

int main() {
    int retCode;
    try {
    retCode = Main(); // transfer control to the student's program
    }
    catch(ErrorException e) { // handle uncaught errors
    cerr << "***" << endl
         << "***  ERROR:  " << e.what() << endl
         << "***" << endl;
    exit(EXIT_FAILURE);
    }
    exit(retCode);
}
/*
 * Function macro: main
 * --------------------
 * The purpose of this macro definition is to rename the student
 * main to Main in order to allow a custom main defined in our
 * libraries to configure the application before passing control
 * back to the student program.
 *
 * Note that this non-Stanford version only affects the zero-argument
 * form of main(), not main(int argc, char* argv[]).
 * If you want to use command-line arguments, you also have to catch
 * your own ErrorException - see init.h/init.cpp for details.
 */

#define main() Main()

//#endif

/*
 * File: genlib.cpp
 * Last modified September 2011 by Colin
 * ----------------
 * This file implements the genlib.h interface
 * It is needed by programs using the Stanford CS106B libraries
 * If the ErrorException is unhandled by student code, it will
 * be caught by init.cpp code, which wraps around the student's
 * main() function
 */

//#include "genlib.h"


ErrorException::ErrorException(string m)
: msg(m) {
}

ErrorException::~ErrorException() throw() {}

const char* ErrorException::what() const throw() {
    return this->msg.c_str();
}

void Error(string str) {
    ErrorException err(str);
    throw err;
}

//#include "init.h"



/* File : simpio.cpp
 * Last modified September 2011 by Colin
 *
 * Based on the discussion in the CS106L Course Reader, chapter 3
 * http://www.stanford.edu/class/cs106l/course_reader.html
 */

#include <sstream>
//#include "genlib.h"


/*
 * Function: GetLine
 * Usage: s = GetLine();
 */
 
string GetLine() {
    string result;

    getline(cin, result);
    if (cin.fail()) {
        result = "";
        cin.clear();
    }

    return result;
}

/*
 * Function: GetInteger
 * Usage: n = GetInteger();
 */
 
int GetInteger() {
    while(true) {
    stringstream converter;
    converter << GetLine();

    int result;
    if (converter >> result) {
        char remaining;
        if(converter >> remaining)
        cout << "Unexpected character: " << remaining << endl;
        else
        return result;
    } else
        cout << "Please enter an integer." << endl;
    }
}


/*
 * Function: GetLong
 * Usage: n = GetLong();
 */
 
long GetLong() {
    while(true) {
    stringstream converter;
    converter << GetLine();

    long result;
    if(converter >> result) {
        char remaining;
        if(converter >> remaining)
        cout << "Unexpected character: " << remaining << endl;
        else
        return result;
    }
    else
        cout << "Please enter an integer (long)." << endl;
   }
}

/*
 * Function: GetReal
 * Usage: x = GetReal();
 */

double GetReal() {
    while(true)    {
    stringstream converter;
    converter << GetLine();

    double result;
    if (converter >> result) {
        char remaining;
        if (converter >> remaining)
        cout << "Unexpected character: " << remaining << endl;
        else
        return result;
    }
    else
        cout << "Please enter a floating-point number.";
    }
}
/*
 * File: strutils.h
 * Last modified on Wed Sep 18 13:37:55 2002 by zelenski
 * -----------------------------------------------------
 * The strutils.h file defines some useful helper functions
 * not included by the C++ string library. These were taken
 * from Eric Roberts's original strlib from his text
 * _The Art and Science of C_.
 */

//#ifndef _strutils_h
//#define _strutils_h



/*
 * Function: IntegerToString
 * Usage: s = IntegerToString(n);
 * ------------------------------
 * This function converts an integer into the corresponding
 * string of digits.  For example, IntegerToString(123)
 * returns "123" as a string.
 */

string IntegerToString(int num);

/*
 * Function: RealToString
 * Usage: s = RealToString(d);
 * ---------------------------
 * This function converts a floating-point number into the
 * corresponding string form.  For example, calling
 * RealToString(23.45) returns "23.45".
 */

string RealToString(double num);

/*
 * Function: StringToInteger
 * Usage: n = StringToInteger(s);
 * ------------------------------
 * This function converts a string of digits into an integer.
 * If the string is not a legal integer or contains extraneous
 * characters, StringToInteger signals an error condition.
 */

int StringToInteger(string str);

/*
 * Function: StringToReal
 * Usage: d = StringToReal(s);
 * ---------------------------
 * This function converts a string representing a real number
 * into its corresponding value.  If the string is not a
 * legal floating-point number or if it contains extraneous
 * characters, StringToReal signals an error condition.
 */

double StringToReal(string str);

/*
 * Function: ConvertToLowerCase
 * Usage: s = ConvertToLowerCase(s);
 * ---------------------------------
 * This function returns a new string with all
 * alphabetic characters converted to lower case.
 */

string ConvertToLowerCase(string s);

/*
 * Function: ConvertToUpperCase
 * Usage: s = ConvertToUpperCase(s);
 * ---------------------------------
 * This function returns a new string with all
 * alphabetic characters converted to upper case.
 */

string ConvertToUpperCase(string s);

//#endif

/* File : strutils.cpp
 * Last modified September 2011
 * -----------------------------------
 * Invalid conversions raise an ErrorException,
 * which will be caught by init.cpp code
 * unless the student chooses to handle them
 */


#include <sstream>
#include <string>

/*
 * Function: IntegerToString
 * Usage: s = IntegerToString(n);
 */

string IntegerToString(int num) {
    stringstream result;
    result << num;
    return result.str();
}

/*
 * Function: RealToString
 * Usage: s = RealToString(d);
 */

string RealToString(double num) {
    stringstream result;
    result << num;
    return result.str();
}

/*
 * Function: StringToInteger
 * Usage: n = StringToInteger(s);
 */

int StringToInteger(string str)
{
    int returnVal;
    istringstream result(str);
    string rest;

    if ((result >> returnVal).fail()) {
    Error("Not a valid number!");
    }
    result >> rest;
    if (rest != "") {
    Error("Extra characters not allowed");
    }
    return returnVal;
}

/*
 * Function: StringToReal
 * Usage: d = StringToReal(s);
 */

double StringToReal(string str) {
    double returnVal;
    istringstream result(str);
    string rest;

    if ((result >> returnVal).fail()) {
    Error("Not a valid number!");
    }
    result >> rest;
    if (rest != "") {
    Error("Extra characters not allowed");
    }
    return returnVal;
}

/*
 * Function: ConvertToLowerCase
 * Usage: s = ConvertToLowerCase(s);
 */

string ConvertToLowerCase(string str)
{
    const int length = str.length();
    for(int i=0; i < length; i++) {
        str[i] = tolower(str[i]);
    }
    return str;
}

/*
 * Function: ConvertToUpperCase
 * Usage: s = ConvertToUpperCase(s);
 */

string ConvertToUpperCase(string str) {
    const int length = str.length();
    for(int i=0; i < length; i++) {
        str[i] = toupper(str[i]);
    }
    return str;
}

/*
 * File: vector.h
 * Last modified on Fri Jun  5 15:35:35 2009 by eroberts
 *      modified on Tue Jan  2 13:56:15 2007 by zelenski
 * -----------------------------------------------------
 * This interface file contains the Vector class template, an
 * efficient, safer, convenient replacement for the built-in array.
 */


//#include "genlib.h"
//#include "strutils.h"
//#include "foreach.h"
/*
 * File: foreach.h
 * Last modified on Thu Jun 11 12:04:09 2009 by eroberts
 * -----------------------------------------------------
 * This interface defines the foreach keyword, which is used to
 * simplify iteration.  All iterable classes import this interface,
 * so clients never need to do so explicitly.
 */


//#include "genlib.h"

/* These #includes are for files that contain "in" as a token */

#include <ios>
#include <fstream>
#include <sstream>

/* Redefine the ios constants (one of which is "in") */

static const ios::openmode IOS_APP = ios::app;
static const ios::openmode IOS_ATE = ios::ate;
static const ios::openmode IOS_BINARY = ios::binary;
static const ios::openmode IOS_IN = ios::in;
static const ios::openmode IOS_OUT = ios::out;
static const ios::openmode IOS_TRUNC = ios::trunc;

/*
 * Class: FE_Iterator
 * ------------------
 * This class is a base class for all Iterators that can work with
 * the foreach construct.  The only purpose of this class is to make
 * it possible to freeing the iterators after they are no longer needed.
 *
 * Note: FE_Iterator is implemented in lexicon.cpp, which is the only
 * iterable class that is not a template class.
 */

class FE_Iterator {
public:
    FE_Iterator();
    ~FE_Iterator();
};

/*
 * Class: FE_State
 * ---------------
 * This class is used to maintain the state of the foreach processing.
 * The class itself is essentially private, but the implementations in
 * the different classes use the fields directly.
 *
 * Note: FE_State is implemented in lexicon.cpp, which is the only
 * iterable class that is not a template class.
 */

class FE_State {
public:
    int state;
    FE_Iterator *iter;

    FE_State();
    ~FE_State();
};

/*
 * Macro: foreach
 * Usage: foreach (type var in collection) { . . . }
 * -------------------------------------------------
 * Provides a much simpler hook to the iterator facility.
 */

#define foreach(arg) \
  for (FE_State _fe; _fe.state < 2; ) \
    for (arg.foreachHook(_fe); _fe.state++ == 1; _fe.state = 0)

#define in =




/*
 * Class: Vector
 * -------------
 * This interface defines a class template that stores a homogeneous
 * indexed collection. The basic operations are similar to those
 * in the built-in array type, with the added features of dynamic
 * memory management, bounds-checking on indexes, and convenient
 * insert/remove operations. Like an array, but better!
 * For maximum generality, the Vector is supplied as a class template.
 * The client specializes the vector to hold values of a specific
 * type, e.g. Vector<int> or Vector<studentT>, as needed
 */

template <typename ElemType>
class Vector {

public:

/* Forward references */
    class Iterator;

/*
 * Constructor: Vector
 * Usage: Vector<int> vec;
 *        Vector<student> dormlist(200);
 *        Vector<string> *vp = new Vector<string>;
 * -----------------------------------------------
 * The constructor initializes a new empty vector. The optional
 * argument is a hint about the expected number of elements that
 * this vector will hold, which allows vector to configure itself
 * for that capacity during initialization.  If not specified,
 * it is initialized with default capacity and grows as elements
 * are added. Note that capacity does NOT mean size, a newly
 * constructed vector always has size() = 0. A large starting
 * capacity allows you to add that many elements without requiring
 * any internal reallocation. The explicit keyword is required to
 * avoid accidental construction of a vector from an int.
 */
    explicit Vector(int sizeHint = 0);

/*
 * Destructor: ~Vector
 * Usage: delete vp;
 * -----------------
 * The destructor deallocates storage associated with this vector.
 */
    ~Vector();

/*
 * Method: size
 * Usage: nElems = vec.size();
 * ---------------------------
 * This method returns the number of elements in
 * this vector.
 */
    int size();

/*
 * Method: isEmpty
 * Usage: if (vec.isEmpty())...
 * -----------------------------
 * This method returns true if this vector contains no
 * elements, false otherwise.
 */
    bool isEmpty();

/*
 * Method: getAt
 * Usage: val = vec.getAt(3);
 * --------------------------
 * This method returns the element at the specified index
 * in this vector. Elements are indexed starting from 0.  A call to
 * vec.getAt(0) returns the first element, vec.getAt(vec.size()-1)
 * returns the last. Raises an error if index is outside the range
 * [0, size()-1].
 */
    ElemType getAt(int index);

/*
 * Method: setAt
 * Usage: vec.setAt(3, value);
 * ---------------------------
 * This method replaces the element at the specified index
 * in this vector with a new value.  The previous value at that
 * index is overwritten with the new value. The size of the vector
 * is unchanged. Raises an error if index is not within the
 * range [0, size()-1].
 */
    void setAt(int index, ElemType value);

/*
 * Method: operator[]
 * Usage: vec[0] = vec[1];
 * -----------------------
 * This method overloads [] to access elements from
 * this vector. This allows the client to use array-like notation
 * to get/set individual vector elements. Returns a reference to
 * the element to allow in-place modification of values. Raises
 * an error if index is not within the range [0, size()-1].
 */
    ElemType & operator[](int index);

/*
 * Method: add
 * Usage: vec.add(value);
 * ----------------------
 * This method adds an element to the end of this vector.
 * The vector's size increases by one.
 */
    void add(ElemType elem);

/*
 * Method: insertAt
 * Usage: vec.insertAt(0, value);
 * ------------------------------
 * This method inserts the element into this vector at
 * the specified index, shifting all subsequent elements one
 * index higher. A call to vec.insertAt(0, val) inserts a new
 * element at the beginning, vec.insertAt(vec.size(), val) add
 * a new element to the end. The vector's size increases by one.
 * Raises an error if index is outside the range [0, size()].
 */
    void insertAt(int index, ElemType elem);

/*
 * Method: removeAt
 * Usage: vec.removeAt(3);
 * -----------------------
 * This method removes the element at the specified
 * index from this vector, shifting all subsequent elements one
 * index lower. A call to vec.removeAt(0) removes the first
 * element, vec.removeAt(vec.size()-1), removes the last. The
 * vector's size decreases by one. Raises an error if index is
 * outside the range [0, size()-1].
 */
    void removeAt(int index);

/*
 * Method: clear
 * Usage: vec.clear();
 * -------------------
 * This method removes all elements from this vector. The
 * vector is made empty and will have size() = 0.
 */
    void clear();

/*
 * SPECIAL NOTE: mapping/iteration support
 * ---------------------------------------
 * The Vector class supports both a mapping operation and an iterator which
 * allow the client access to all elements one by one.  In general,
 * these  are intended for _viewing_ elements and can behave
 * unpredictably if you attempt to modify the vector's contents during
 * mapping/iteration.
 */

/*
 * Method: mapAll
 * Usage: vector.mapAll(Print);
 * ----------------------------
 * This method iterates through this vector's contents
 * and calls the function fn once for each element.
 */
    void mapAll(void (*fn)(ElemType elem));

/*
 * Method: mapAll
 * Usage: vector.mapAll(PrintToFile, outputStream);
 * ------------------------------------------------
 * This method iterates through this vector's contents
 * and calls the function fn once for each element, passing
 * the element and the client's data. That data can be of whatever
 * type is needed for the client's callback.
 */
    template <typename ClientDataType>
    void mapAll(void (*fn)(ElemType elem, ClientDataType & data),
                ClientDataType & data);

/*
 * Method: iterator
 * Usage: iter = vector.iterator();
 * --------------------------------
 * This method creates an iterator that allows the client to
 * iterate through the elements in this vector.  The elements are
 * returned in index order.
 *
 * The idiomatic code for accessing elements using an iterator is
 * to create the iterator from the collection and then enter a loop
 * that calls next() while hasNext() is true, like this:
 *
 *     Vector<int>::Iterator iter = vector.iterator();
 *     while (iter.hasNext()) {
 *         int elem = iter.next();
 *         . . .
 *     }
 *
 * This pattern can be abbreviated to the following more readable form:
 *
 *     foreach (int elem in vector) {
 *         . . .
 *     }
 *
 * To avoid exposing the details of the class, the definition of the
 * Iterator class itself appears in the private/vector.h file.
 */
    Iterator iterator();

private:

    /*
     * File: private/vector.h
     * Last modified on Fri Jun  5 15:39:26 2009 by eroberts
     * -----------------------------------------------------
     * This file contains the private section of the vector.h interface.
     * This portion of the class definition is taken out of the vector.h
     * header so that the client need not have to see all of these
     * details.
     */

    public:

    /*
     * Class: Vector<ElemType>::Iterator
     * ---------------------------------
     * This interface defines a nested class within the Vector template that
     * provides iterator access to the Vector contents.
     */
        class Iterator : public FE_Iterator {
        public:
            Iterator();
            bool hasNext();
            ElemType next();

        private:
            Iterator(Vector *vecRef);
            Vector *vp;
            int curIndex;
            long timestamp;
            friend class Vector;
        };
        friend class Iterator;
        ElemType foreachHook(FE_State & _fe);

    /*
     * Deep copying support
     * --------------------
     * This copy constructor and operator= are defined to make a
     * deep copy, making it possible to pass/return vectors by value
     * and assign from one vector to another. The entire contents of
     * the vector, including all elements, are copied. Each vector
     * element is copied from the original vector to the copy using
     * assignment (operator=). Making copies is generally avoided
     * because of the expense and thus, vectors are typically passed
     * by reference, however, when a copy is needed, these operations
     * are supported.
     */
        const Vector & operator=(const Vector & rhs);
        Vector(const Vector & rhs);

    private:
        ElemType *elements;
        int numAllocated, numUsed;
        long timestamp;

        void checkRange(int index, const char *msg);
        void enlargeCapacity();
        void copyInternalData(const Vector & other);


};

//#include "private/vector.cpp"

//#endif
/*
 * File: private/vector.cpp
 * Last modified on Fri Jun  5 16:19:42 2009 by eroberts
 * -----------------------------------------------------
 * This file contains the implementation of the vector.h interface.
 * Because of the way C++ compiles templates, this code must be
 * available to the compiler when it reads the header file.
 */

//#ifdef _vector_h

/*
 * Vector class implementation
 * ---------------------------
 * The Vector is internally managed as a dynamic array of elements.
 * It tracks capacity (numAllocated) separately from size (numUsed).
 * All access is bounds-checked for safety.
 */

template <typename ElemType>
Vector<ElemType>::Vector(int capacity) {
    elements = new ElemType[capacity];
    numAllocated = capacity;
    numUsed = 0;
    timestamp = 0L;
}

template <typename ElemType>
Vector<ElemType>::~Vector() {
    if (elements != NULL) delete[] elements;
}

template <typename ElemType>
inline int Vector<ElemType>::size() {
    return numUsed;
}

template <typename ElemType>
bool Vector<ElemType>::isEmpty() {
    return size() == 0;
}

template <typename ElemType>
ElemType Vector<ElemType>::getAt(int index) {
    checkRange(index, "getAt");
    return elements[index];
}

template <typename ElemType>
void Vector<ElemType>::setAt(int index, ElemType elem) {
    checkRange(index, "setAt");
    elements[index] = elem;
}

/* Private method: checkRange
 * --------------------------
 * Verifies that index is in range for this vector, if not, raises an
 * error.  The verb string is used in the error message to describe the
 * operation that caused the range error, .e.g "setAt" or "removeAt".
 */

template <typename ElemType>
inline void Vector<ElemType>::checkRange(int index, const char *verb) {
    if (index < 0 || index >= size()) {
        Error("Attempt to " + string(verb) + " index "
              + IntegerToString(index) + " in a vector of size "
              + IntegerToString(size()) + ".");
    }
}

template <typename ElemType>
inline ElemType &Vector<ElemType>::operator[](int index) {
    checkRange(index, "access");
    return elements[index];
}

template <typename ElemType>
void Vector<ElemType>::add(ElemType elem) {
    insertAt(numUsed, elem);
}

template <typename ElemType>
void Vector<ElemType>::insertAt(int index, ElemType elem) {
    if (numAllocated == numUsed) enlargeCapacity();
    if (index != numUsed) checkRange(index, "insertAt");
    for (int i = numUsed; i > index; i--) {
        elements[i] = elements[i-1];
    }
    elements[index] = elem;
    numUsed++;
    timestamp++;
}

template <typename ElemType>
void Vector<ElemType>::removeAt(int index) {
    checkRange(index, "removeAt");
    for (int i = index; i < numUsed-1; i++) {
        elements[i] = elements[i+1];
    }
    numUsed--;
    timestamp++;
}

template <typename ElemType>
void Vector<ElemType>::clear() {
    delete[] elements;
    elements = NULL;
    numUsed = numAllocated = 0;
    timestamp++;
}

template <typename ElemType>
const Vector<ElemType> &Vector<ElemType>::operator=(const Vector & rhs) {
    if (this != &rhs) {
        clear();
        copyInternalData(rhs);
        timestamp = 0L;
    }
    return *this;
}

template <typename ElemType>
Vector<ElemType>::Vector(const Vector & rhs) {
    copyInternalData(rhs);
    timestamp = 0L;
}

template <typename ElemType>
void Vector<ElemType>::mapAll(void (*fn)(ElemType)) {
    long t0 = timestamp;
    for (int i = 0; i < numUsed; i++) {
        if (timestamp != t0) {
            Error("Vector structure has been modified");
        }
        fn(elements[i]);
    }
}

template <typename ElemType>
template <typename ClientDataType>
void Vector<ElemType>::mapAll(void (*fn)(ElemType, ClientDataType&),
                              ClientDataType & data) {
    long t0 = timestamp;
    for (int i = 0; i < numUsed; i++) {
        if (timestamp != t0) {
            Error("Vector structure has been modified");
        }
        fn(elements[i], data);
    }
}

/*
 * Vector::Iterator class implementation
 * ----------------------------------
 * The Iterator for Vector maintains a pointer to the original Vector and
 * an index into that vector that identifies the next element to return.
 */

template <typename ElemType>
Vector<ElemType>::Iterator::Iterator() {
    vp = NULL;
}

template <typename ElemType>
typename Vector<ElemType>::Iterator Vector<ElemType>::iterator() {
    return Iterator(this);
}

template <typename ElemType>
Vector<ElemType>::Iterator::Iterator(Vector *vecRef) {
    vp = vecRef;
    curIndex = 0;
    timestamp = vp->timestamp;
}

template <typename ElemType>
bool Vector<ElemType>::Iterator::hasNext() {
    if (vp == NULL) Error("hasNext called on uninitialized iterator");
    if (timestamp != vp->timestamp) {
        Error("Vector structure has been modified");
    }
    return curIndex < vp->size();
}

template <typename ElemType>
ElemType Vector<ElemType>::Iterator::next() {
    if (vp == NULL) Error("next called on uninitialized iterator");
    if (!hasNext()) {
        Error("Attempt to get next from iterator"
              " where hasNext() is false");
    }
    return (*vp)[curIndex++];
}

template <typename ElemType>
ElemType Vector<ElemType>::foreachHook(FE_State & fe) {
    if (fe.state == 0) fe.iter = new Iterator(this);
    if (((Iterator *) fe.iter)->hasNext()) {
        fe.state = 1;
        return ((Iterator *) fe.iter)->next();
    } else {
        fe.state = 2;
        return ElemType();
    }
}

/* Private method: enlargeCapacity
 * -------------------------------
 * Doubles the current capacity of the vector's internal storage,
 * copying all existing values.
 */

template <typename ElemType>
void Vector<ElemType>::enlargeCapacity() {
    numAllocated = (numAllocated == 0 ? 10 : numAllocated*2);
    ElemType *newArray = new ElemType[numAllocated];
    for (int i = 0; i < numUsed; i++) {
        newArray[i] = elements[i];
    }
    delete[] elements;
    elements = newArray;
}

/* Private method: copyInternalData
 * --------------------------------
 * Common code factored out of the copy constructor and operator= to
 * copy the contents from the other vector.
 */

template <typename ElemType>
void Vector<ElemType>::copyInternalData(const Vector & other) {
    elements = new ElemType[other.numUsed];
    for (int i = 0; i < other.numUsed; i++) {
        elements[i] = other.elements[i];
    }
    numUsed = other.numUsed;
    numAllocated = other.numUsed;
}

//#endif

/*
 * File: queue.h
 * Last modified on Fri Jun  5 15:36:11 2009 by eroberts
 *      modified on Tue Jan  2 13:51:36 2007 by zelenski
 * -----------------------------------------------------
 * This interface file contains the Queue class template,
 * which provides a linear FIFO collection.
 */

//#ifndef _queue_h
//#define _queue_h

//#include "genlib.h"

/*
 * Class: Queue
 * ------------
 * This interface defines a class that models a queue, or waiting
 * line. It is a linear collection managed in first-in-first-out
 * order. Values are added to the end and removed from the front.
 * The queue operations are enqueue (add to end) and dequeue (remove
 * from front).
 *
 * For maximum generality, the Queue is supplied as a class template.
 * The client specializes the queue to hold values of a specific type,
 * e.g. Queue<customerT> or Queue<string>, as needed
 */

template <typename ElemType>
class Queue {

public:

/*
 * Constructor: Queue
 * Usage: Queue<int> queue;
 *        Queue<string> *qp = new Queue<string>;
 * ---------------------------------------------
 * The constructor initializes a new empty queue.
 */
    Queue();

/*
 * Destructor: ~Queue
 * Usage: delete qp;
 * -----------------
 * The destructor deallocates storage associated with this queue.
 */
    ~Queue();

/*
 * Method: size
 * Usage: nElems = queue.size();
 * -----------------------------
 * This method returns the number of elements in this queue.
 */
    int size();

/*
 * Method: isEmpty
 * Usage: if (queue.isEmpty())...
 * -------------------------------
 * This method returns true if this queue contains no
 * elements, false otherwise.
 */
    bool isEmpty();

/*
 * Method: enqueue
 * Usage: queue.enqueue(element);
 * -------------------------------
 * This method adds element to the end of this queue. That
 * element becomes the last element in the queue. The queue's size
 * increases by one.
 */
    void enqueue(ElemType elem);

/*
 * Method: dequeue
 * Usage: first = queue.dequeue();
 * -------------------------------
 * This method removes the front element from this queue
 * and returns it. The front element is the one that was first
 * enqueued. The queue's size decreases by one. This function
 * raises an error if called on an empty queue.
 */
    ElemType dequeue();

/*
 * Method: peek
 * Usage: first = queue.peek();
 * --------------------------
 * This method returns the value of front element in this
 * queue, without removing it.  The queue's size is unchanged.
 * Raises an error if peek is called on an empty queue.
 */
    ElemType peek();

/*
 * Method: clear
 * Usage: queue.clear();
 * ---------------------
 * This method removes all elements from this queue. The
 * queue is made empty and will have size() = 0.
 */
    void clear();

private:

//#include "private/queue.h"
    /*
     * File: private/queue.h
     * Last modified on Fri Jun  5 10:06:00 2009 by eroberts
     * -----------------------------------------------------
     * This file contains the private section of the queue.h interface.
     * This portion of the class definition is taken out of the queue.h
     * header so that the client need not have to see all of these
     * details.
     */

    public:

    /*
     * Deep copying support
     * --------------------
     * This copy constructor and operator= are defined to make a
     * deep copy, making it possible to pass/return queues by value
     * and assign from one queue to another. The entire contents of
     * the queue, including all elements, are copied. Each queue
     * element is copied from the original queue to the copy using
     * assignment (operator=). Making copies is generally avoided
     * because of the expense and thus, queues are typically passed
     * by reference, however, when a copy is needed, these operations
     * are supported.
     */
        const Queue & operator=(const Queue & rhs);
        Queue(const Queue & rhs);

    private:
        struct cellT {
            ElemType elem;
            cellT *next;
        };

        cellT *head;
        cellT *tail;
        int count;
        void deleteCells();
        void copyOtherData(const Queue & rhs);

};

//#include "private/queue.cpp"
/*
 * File: private/queue.cpp
 * Last modified on Tue Jun  9 07:53:03 2009 by eroberts
 * -----------------------------------------------------
 * This file contains the implementation of the queue.h interface.
 * Because of the way C++ compiles templates, this code must be
 * available to the compiler when it reads the header file.
 */

//#ifdef _queue_h

/*
 * Queue class implementation
 * --------------------------
 * The Queue is internally managed as a singly linked list of cells, with a
 * head and tail pointer.  The front of the queue is at the head; the end
 * is at the tail.
 */

template <typename ElemType>
Queue<ElemType>::Queue() {
    head = tail = NULL;
    count = 0;
}

template <typename ElemType>
Queue<ElemType>::~Queue() {
    deleteCells();
}

template <typename ElemType>
int Queue<ElemType>::size() {
    return count;
}

template <typename ElemType>
bool Queue<ElemType>::isEmpty() {
    return count == 0;
}

template <typename ElemType>
void Queue<ElemType>::enqueue(ElemType elem) {
    cellT *newOne = new cellT;
    newOne->elem = elem;
    newOne->next = NULL;
    if (head != NULL) {
        tail->next = newOne;
    } else {
        head = newOne;
    }
    tail = newOne;
    count++;
}

template <typename ElemType>
ElemType Queue<ElemType>::dequeue() {
    if (isEmpty()) Error("Attempt to dequeue from empty queue");
    ElemType first = head->elem;
    cellT *toDelete = head;
    head = head->next;
    delete toDelete;
    count--;
    return first;
}

template <typename ElemType>
ElemType Queue<ElemType>::peek() {
    if (isEmpty()) Error("Attempt to peek at empty queue");
    return head->elem;
}

template <typename ElemType>
void Queue<ElemType>::clear() {
    deleteCells();
    count = 0;
}

template <typename ElemType>
void Queue<ElemType>::deleteCells() {
    while (head != NULL) {
        cellT *next = head->next;
        delete head;
        head = next;
    }
    tail = NULL;
}

template <typename ElemType>
const Queue<ElemType> &Queue<ElemType>::operator=(const Queue & rhs) {
    if (this != &rhs) {
        clear();
        copyOtherData(rhs);
    }
    return *this;
}

template <typename ElemType>
Queue<ElemType>::Queue(const Queue & rhs) {
    head = tail = NULL;
    count = 0;
    copyOtherData(rhs);
}

template <typename ElemType>
void Queue<ElemType>::copyOtherData(const Queue & rhs) {
    for (cellT *cur = rhs.head; cur != NULL; cur = cur->next) {
        enqueue(cur->elem);
    }
}
//#endif

//#endif
/*
 * File: stack.h
 * Last modified on Wed Apr  1 08:22:08 2009 by eroberts
 *      modified on Tue Jan  2 13:40:51 2007 by zelenski
 * -----------------------------------------------------
 * This interface file contains the Stack class template,
 * which provides a linear LIFO collection.
 */

//#ifndef _stack_h
//#define _stack_h

//#include "vector.h"

/*
 * Class: Stack
 * ------------
 * This interface defines a class template that models a "stack":
 * that is, a linear collection of values stacked one on top of
 * the other. Values added and removed only from the top of the stack.
 * The fundamental stack operations are push (add to top) and pop
 * (remove from top). A stack is said to operate in last-in-first-out
 * (LIFO) order.
 *
 * For maximum generality, the Stack is supplied as a class template.
 * The client specializes the stack to hold values of a specific type,
 * e.g. Stack<string> or Stack<stateT>, as needed.
 */

template <typename ElemType>
class Stack {

public:

/*
 * Constructor: Stack
 * Usage: Stack<int> stack;
 *        Stack<string> *sp = new Stack<string>;
 * ---------------------------------------------
 * The constructor initializes a new empty stack.
 */
    Stack();

/*
 * Destructor: ~Stack
 * Usage: delete sp;
 * -----------------
 * The destructor deallocates storage associated with this stack.
 */
    ~Stack();

/*
 * Method: size
 * Usage: nElems = stack.size();
 * -----------------------------
 * This method returns the number of elements in this stack.
 */
    int size();

/*
 * Method: isEmpty
 * Usage: if (stack.isEmpty())...
 * -------------------------------
 * This method returns true if this stack contains no
 * elements, false otherwise.
 */
    bool isEmpty();

/*
 * Method: push
 * Usage: stack.push(element);
 * ----------------------------
 * This method pushes the specified element onto this
 * stack. That element becomes the top element on the stack. The
 * stack's size increases by one.
 */
    void push(ElemType elem);

/*
 * Method: pop
 * Usage: top = stack.pop();
 * -------------------------
 * This method removes the top element from this stack and
 * returns it. The top element is the one that was last pushed. The
 * stack's size decreases by one. This function raises an error if
 * called on an empty stack.
 */
    ElemType pop();

/*
 * Method: peek
 * Usage: top = stack.peek();
 * --------------------------
 * This method returns the value of top element from this
 * stack, without removing it.  The stack's size is unchanged.
 * Raises an error if peek is called on an empty stack.
 */
    ElemType peek();

/*
 * Method: clear
 * Usage: stack.clear();
 * ---------------------
 * This method removes all elements from this stack. The
 * stack is made empty and will have size() = 0.
 */
    void clear();

private:

//#include "private/stack.h"
    /*
     * File: private/stack.h
     * Last modified on Fri Jun  5 10:50:28 2009 by eroberts
     * -----------------------------------------------------
     * This file contains the private section of the stack.h interface.
     * This portion of the class definition is taken out of the stack.h
     * header so that the client need not have to see all of these
     * details.
     */

    public:

    /*
     * Deep copying support
     * --------------------
     * Because all data members have correct behavior on operator=
     * and copy constructor, the default as synthesized by
     * the compiler make a correct copy of the Stack. When pass/return
     * stacks by value, or assign one to another, the entire contents
     * of the stack, including all elements, are copied. Each stack
     * element is copied from the original stack to the copy using
     * assignment (operator=). Making copies is generally avoided
     * because of the expense and thus, stacks are typically passed by
     * reference, however, when a copy is needed, these operations
     * correctly are supported.
     *
     * const Stack & operator=(const Stack & rhs);
     * Stack(const Stack & rhs);
     */

    private:
        Vector<ElemType> elems;

};

//#include "private/stack.cpp"
/*
 * File: private/stack.cpp
 * Last modified on Fri Jun  5 10:51:26 2009 by eroberts
 * -----------------------------------------------------
 * This file contains the implementation of the stack.h interface.
 * Because of the way C++ compiles templates, this code must be
 * available to the compiler when it reads the header file.
 */

//#ifdef _stack_h

/*
 * Stack class implementation
 * ---------------------------
 * The Stack is internally managed using a Vector. This layered
 * implementation makes the job quite trivial, most methods are
 * one-liners.
 */

template <typename ElemType>
Stack<ElemType>::Stack() {
    /* Empty */
}

template <typename ElemType>
Stack<ElemType>::~Stack() {
    /* Empty */
}

template <typename ElemType>
int Stack<ElemType>::size() {
    return elems.size();
}

template <typename ElemType>
bool Stack<ElemType>::isEmpty() {
    return size() == 0;
}

template <typename ElemType>
void Stack<ElemType>::push(ElemType elem) {
    elems.add(elem);
}

template <typename ElemType>
ElemType Stack<ElemType>::pop() {
    if (isEmpty()) Error("Attempt to pop from empty stack");
    ElemType top = elems[elems.size()-1];
    elems.removeAt(elems.size()-1);
    return top;
}

template <typename ElemType>
ElemType Stack<ElemType>::peek() {
    if (isEmpty()) Error("Attempt to peek at empty stack");
    return elems[elems.size()-1];
}

template <typename ElemType>
void Stack<ElemType>::clear() {
    elems.clear();
}

//#endif

//#endif

/*
 * File: scanner.h
 * Last modified on Tue Jun  9 00:19:57 2009 by eroberts
 * -----------------------------------------------------
 * This file is the interface for a class that facilitates dividing
 * a string into logical units  called "tokens", which are either
 *
 * 1. Strings of consecutive letters and digits representing words
 * 2. One-character strings representing punctuation or separators
 *
 * To use this class, you must first create an instance of a
 * Scanner object by declaring
 *
 *      Scanner scanner;
 *
 * You initialize the scanner's input in one of two ways.  First,
 * you can read input from a string by calling
 *
 *      scanner.setInput(str);
 *
 * where str is the string from which tokens should be read.
 * Alternatively, you can retrieve tokens from an input file
 * by calling
 *
 *      scanner.setInput(infile);
 *
 * where infile is an open istream object.  In either case, you
 * can then retrieve the next token by making the following call:
 *
 *      token = scanner.nextToken();
 *
 * To determine whether any tokens remain to be read, you can call
 * the predicate method scanner.hasMoreTokens().  The nextToken
 * method returns the empty string after the last token is read.
 *
 * The following code fragment serves as an idiom for processing
 * each token in the string inputString:
 *
 *      Scanner scanner;
 *      scanner.setInput(inputString);
 *      while (scanner.hasMoreTokens()) {
 *          string token = scanner.nextToken();
 *          . . . process the token . . .
 *      }
 *
 * Note that it is possible for clients to have more than one scanner
 * active at the same time.  For instance
 *
 *      Scanner scannerX, scannerY;
 *
 * creates two independent scanner objects.  The client specifies a
 * particular object name before the "." in a method call to
 * identify which particular instance of the scanner is to be used.
 *
 * The Scanner class also supports the following advanced features,
 * which are documented later in the interface:
 *
 *   saveToken
 *   setSpaceOption
 *   setStringOption
 *   setNumberOption
 *   setBracketOption
 */

//#ifndef _scanner_h
//#define _scanner_h

//#include "genlib.h"
//#include "stack.h"
#include <string>
#include <iostream>

/*
 * Class: Scanner
 * --------------
 * This class is used to represent a single instance
 * of a scanner.
 */

class Scanner {
public:

/*
 * Constructor: Scanner
 * Usage: Scanner scanner;
 *        Scanner *sp = new Scanner;
 * ---------------------------------
 * The constructor initializes a new scanner object. The scanner
 * starts empty, with no input to scan.
 */
    Scanner();

/*
 * Destructor: ~Scanner
 * Usage: delete sp;
 * -----------------
 * The destructor deallocates the storage associated with this scanner.
 */
    ~Scanner();

/*
 * Method: setInput
 * Usage: scanner.setInput(str);
 * -----------------------------
 * This method configures this scanner to start extracting
 * tokens from the input string str. Any previous input string is
 * discarded.
 */
    void setInput(string str);

/*
 * Method: setInput
 * Usage: scanner.setInput(infile);
 * --------------------------------
 * This method configures this scanner to start extracting
 * tokens from the input file represented by the istream
 * infile.  Any previous input string is discarded.
 */
    void setInput(istream & infile);

/*
 * Method: nextToken
 * Usage: token = scanner.nextToken();
 * -----------------------------------
 * This method returns the next token from this scanner.  If
 * nextToken is called when no tokens are available, it returns the
 * empty string.
 */
    string nextToken();

/*
 * Method: hasMoreTokens
 * Usage: if (scanner.hasMoreTokens()) . . .
 * ------------------------------------------
 * This method returns true as long as there are additional
 * tokens for this scanner to read.
 */
    bool hasMoreTokens();

/*
 * Method: saveToken
 * Usage: scanner.saveToken(token);
 * --------------------------------
 * This method restores token into this scanner's input
 * in such a way that the next time nextToken is called, the scanner
 * will return this token without reading any additional characters
 * from the input.
 */
    void saveToken(string token);

/*
 * Methods: setSpaceOption, getSpaceOption
 * Usage: scanner.setSpaceOption(option);
 *        option = scanner.getSpaceOption();
 * ------------------------------------------
 * This method controls whether this scanner
 * ignores whitespace characters or treats them as valid tokens.
 * By default, the nextToken function treats whitespace characters,
 * such as spaces and tabs, just like any other punctuation mark.
 * If, however, you call
 *
 *    scanner.setSpaceOption(Scanner::IgnoreSpaces);
 *
 * the scanner will skip over any white space before reading a
 * token. You can restore the original behavior by calling
 *
 *    scanner.setSpaceOption(Scanner::PreserveSpaces);
 *
 * The getSpaceOption function returns the current setting
 * of this option.
 */
    enum spaceOptionT { PreserveSpaces, IgnoreSpaces };

    void setSpaceOption(spaceOptionT option);
    spaceOptionT getSpaceOption();

/*
 * Methods: setNumberOption, getNumberOption
 * Usage: scanner.setNumberOption(option);
 *        option = scanner.getNumberOption();
 * --------------------------------------------------
 * This method controls whether this scanner treats numeric
 * values specially.  The default behavior for a scanner is to treat
 * digits as equivalent to letters.  If you call
 *
 *    scanner.setNumberOption(Scanner::ScanNumbersAsIntegers);
 *
 * a token beginning with a digit will end at the first nondigit.
 * (Note that digits can still be scanned as part of a token as in
 * the token "x1".)  If you call
 *
 *    scanner.setNumberOption(Scanner::ScanNumbersAsReals);
 *
 * the scanner will return the longest token string that represents
 * a real number, if the next character to be scanned is a digit.
 * The format for a real number is a sequence of digit characters
 * that may include at most one decimal point, optionally followed
 * by the letter 'E' in either upper- or lowercase, an optional sign,
 * and an exponent.  You can restore the default behavior by calling
 *
 *    scanner.setNumberOption(Scanner::ScanNumbersAsLetters);
 *
 * Even if the number options are enabled, nextToken always returns
 * its result as a string, which means that you need to call
 * StringToInteger or StringToReal to convert the token to a number.
 */
    enum numberOptionT {
        ScanNumbersAsLetters,
        ScanNumbersAsIntegers,
        ScanNumbersAsReals
    };

    void setNumberOption(numberOptionT option);
    numberOptionT getNumberOption();

/*
 * Methods: setStringOption, getStringOption
 * Usage: scanner.setStringOption(option);
 *        option = scanner.getStringOption();
 * --------------------------------------------------
 * This method controls how this scanner treats double
 * quotation marks in the input.  The default behavior for a scanner
 * is to treat quotes just like any other punctuation character.
 * If, however, you call
 *
 *    scanner.setStringOption(Scanner::ScanQuotesAsStrings);
 *
 * a token beginning with a quotation mark will be scanned up to
 * the closing quotation mark.  The quotation marks are returned
 * as part of the scanned token so that clients can differentiate
 * strings from other token types.  The original behavior can be
 * restored by calling
 *
 *    scanner.setStringOption(Scanner::ScanQuotesAsPunctuation);
 *
 * When scanning a string, the scanner recognizes the standard
 * escape sequences from ANSI C, such as \n and \t.
 */
    enum stringOptionT { ScanQuotesAsPunctuation, ScanQuotesAsStrings };

    void setStringOption(stringOptionT option);
    stringOptionT getStringOption();

/*
 * Methods: setBracketOption, getBracketOption
 * Usage: scanner.setBracketOption(option);
 *        option = scanner.getBracketOption();
 * --------------------------------------------
 * This method controls how this scanner treats angle
 * brackets in the input.  The default behavior for a scanner is
 * to treat brackets just like any other punctuation character.
 * If, however, you call
 *
 *    scanner.setBracketOption(Scanner::ScanBracketsAsTag);
 *
 * a token beginning with a open < bracket will be scanned up to
 * the closing > bracket.  The brackets are returned
 * as part of the scanned token so that clients can differentiate
 * tags from other token types.  The original behavior can be
 * restored by calling
 *
 *    scanner.setBracketOption(Scanner::ScanBracketsAsPunctuation);
 *
 */
    enum bracketOptionT { ScanBracketsAsPunctuation, ScanBracketsAsTag };

    void setBracketOption(bracketOptionT option);
    bracketOptionT getBracketOption();

private:

//#include "private/scanner.h"

    /*
     * File: private/scanner.h
     * Last modified on Tue Jun  9 00:19:57 2009 by eroberts
     * -----------------------------------------------------
     * This file contains the private section of the scanner.h interface.
     * This portion of the class definition is taken out of the scanner.h
     * header so that the client need not have to see all of these
     * details.
     */

        enum realNumScanStateT {
            InitialState,
            BeforeDecimalPoint,
            AfterDecimalPoint,
            StartingExponent,
            FoundExponentSign,
            ScanningExponent,
            FinalState
        };

        string buffer;
        int len; // buflen; in the original
        int cp;
        istream *fp;
        spaceOptionT spaceOption;
        numberOptionT numberOption;
        stringOptionT stringOption;
        bracketOptionT bracketOption;
        Stack<string> savedTokens;

        void skipSpaces();
        int scanToEndOfIdentifier();
        int scanToEndOfInteger();
        int scanToEndOfReal();
        string scanQuotedString();
        char scanEscapeCharacter();
        string scanTag();

};

//#endif
/*
 * File: scanner.cpp
 * -----------------
 * Implementation for the simplified Scanner class.
 * Code taken from the CS106B/X Course Reader, page 332, Figure 9.6
 */

//#include "genlib.h"
//#include "scanner.h"
#include <cctype>
#include <iostream>

/*
 * The details of the representation are inaccessible to the client,
 * but consist of the following fields:
 *
 * buffer -- String passed to setInput
 * len -- Length of buffer, saved for efficiency
 * cp -- Current character position in the buffer
 * spaceOption -- Setting of the space option extension
 */

Scanner::Scanner() {
    buffer = "";
    spaceOption = PreserveSpaces;
}

Scanner::~Scanner() {
    /* Empty */
}

void Scanner::setInput(string str) {
    buffer = str;
    len = buffer.length();
    cp = 0;
}

/*
 * Implementation notes: nextToken
 * -------------------------------
 * The code for nextToken follows from the definition of a token.
 */

string Scanner::nextToken() {
    if (cp == -1) {
    Error("setInput has not been called");
    }
    if (spaceOption == IgnoreSpaces) skipSpaces();
    int start = cp;
    if (start >= len) return "";
    if (isalnum(buffer[cp])) {
    int finish = scanToEndOfIdentifier();
    return buffer.substr(start, finish - start + 1);
    }
    cp++;
    return buffer.substr(start, 1);
}

bool Scanner::hasMoreTokens() {
    if (cp == -1) {
    Error("setInput has not been called");
    }
    if (spaceOption == IgnoreSpaces) skipSpaces();
    return (cp < len);
}

void Scanner::setSpaceOption(spaceOptionT option) {
    spaceOption = option;
}

Scanner::spaceOptionT Scanner::getSpaceOption() {
    return spaceOption;
}

/* Private functions */

/*
 * Private method: skipSpaces
 * Usage: skipSpaces();
 * -------------------
 * This function advances the position of the scanner until the
 * current character is not a whitespace character.
 */

void Scanner::skipSpaces() {
    while (cp < len && isspace(buffer[cp])) {
    cp++;
    }
}

/*
 * Private method: scanToEndOfIdentifier
 * Usage: finish = scanToEndOfIdentifier();
 * ----------------------------------------
 * This function advances the position of the scanner until it
 * reaches the end of a sequence of letters or digits that make
 * up an identifier. The return value is the index of the last
 * character in the identifier; the value of the stored index
 * cp is the first character after that.
 */

int Scanner::scanToEndOfIdentifier() {
    while (cp < len && isalnum(buffer[cp])) {
    cp++;
    }
    return cp - 1;
}

/*
 * File: map.h
 * Last modified on Fri Jun  5 15:06:35 2009 by eroberts
 *      modified on Tue Jan  2 14:14:44 2007 by zelenski
 * -----------------------------------------------------
 * This interface file contains the Map class template, a
 * collection for efficiently storing key-value pairs.
 */

//#ifndef _map_h
//#define _map_h

//#include "genlib.h"
//#include "vector.h"
//#include "foreach.h"
#include <string>
#include <cstdlib>

/*
 * Class: Map
 * ----------
 * This interface defines a class template that stores a collection of
 * key-value pairs.  For maximum generality, the Map is supplied as a
 * class template.  The keys are always of type string, but the value
 * type is set by the client. The client specializes the map to hold
 * values of a specific type, e.g. Map<int> or Map<studentT>, as needed.
 */

template <typename ValueType>
class Map {

public:

/* Forward references */
    class Iterator;

/*
 * Constructor: Map
 * Usage: Map<int> map;
 *        Map<int> map(500);
 *        Map<string> *mp = new Map<string>;
 * -----------------------------------------
 * The constructor initializes a new empty map. The optional
 * argument is a hint about the expected number of entries
 * that this map will hold, which allows the map to configure
 * itself for efficiency at that size.  If not specified, a
 * reasonable default is used and the map will adapt as entries
 * are added. The explicit keyword is used to prevent
 * accidental construction of a Map from an integer.
 * Raises an error if sizeHint is negative.
 */
    explicit Map(int sizeHint = 101);

/*
 * Destructor: ~Map
 * Usage: delete mp;
 * -----------------
 * The destructor deallocates  storage associated with this map.
 */
    ~Map();

/*
 * Method: size
 * Usage: nEntries = map.size();
 * -----------------------------
 * This method returns the number of entries in this map.
 */
    int size();

/*
 * Method: isEmpty
 * Usage: if (map.isEmpty())...
 * ----------------------------
 * This method returns true if this map contains no
 * entries, false otherwise.
 */
    bool isEmpty();

/*
 * Method: put
 * Usage: map.put(key, value);
 * ---------------------------
 * This method associates key with value in this map.
 * Any previous value associated with key is replaced by this new
 * entry. If there was already an entry for this key, the map's
 * size is unchanged; otherwise, it increments by one.
 */
    void put(string key, ValueType value);

/*
 * Method: remove
 * Usage: map.remove(key);
 * -----------------------
 * This method removes any entry for key from this map.
 * If there is no entry for the key, the map is unchanged.
 * Otherwise, the key and its associated value are removed and
 * the map's size decreases by one.
 */
    void remove(string key);

/*
 * Method: containsKey
 * Usage: if (map.containsKey(key))...
 * -----------------------------------
 * Returns true if there is an entry for key in this map,
 * false otherwise.
 */
    bool containsKey(string key);

/*
 * Method: get
 * Usage: value = map.get(key);
 * ---------------------------------
 * If key is found in this map, this method returns the
 * associated value.  If key is not found, raises an error. The
 * containsKey method can be used to verify the presence
 * of a key in the map before attempting to get its value.
 */
    ValueType get(string key);

/*
 * Method: operator[]
 * Usage: map[key] = newValue;
 * ---------------------------
 * This method overloads [] to access values from this
 * map by key. The argument inside the brackets is the key (a
 * string). This allows the client to use notation of an
 * "associative-array" to get/set the value associated with a key.
 * If the key is already present in the map, this function returns
 * a reference to its associated value, and the size of the map is
 * unchanged. If key is not present in the map, a new entry for the
 * key is added, and the size of the map increases by one. The
 * value for the newly entered key is set to the default for value
 * type, and a reference to that value is returned.  Because this
 * function returns the value by reference, it allows in-place
 * modification of the value.
 */
    ValueType & operator[](string key);

/*
 * Method: clear
 * Usage: map.clear();
 * -------------------
 * This method removes all entries from this map. The
 * map is made empty and will have size() = 0 after being cleared.
 */
    void clear();

/*
 * SPECIAL NOTE: mapping/iteration support
 * ---------------------------------------
 * The map supports both a mapping operation and an iterator which
 * allow the client access to all entries one by one.  In general,
 * these  are intended for _viewing_ entries and can behave
 * unpredictably if you attempt to modify the map's contents during
 * mapping/iteration.
 */

/*
 * Method: mapAll
 * Usage: map.mapAll(Print);
 * -------------------------
 * This method goes through every entry in this map
 * and calls the function fn, passing it two arguments:
 * the key and its associated value.
 */
    void mapAll(void (*fn)(string key, ValueType val));

/*
 * Method: mapAll
 * Usage: map.mapAll(PrintToFile, outputStream);
 * ---------------------------------------------
 * This method goes through every entry in this map
 * and calls the function fn, passing it three arguments:
 * the key, its associated value, and the client's data. That data
 * can be of whatever type is needed for the client's callback.
 */
    template <typename ClientDataType>
    void mapAll(void (*fn)(string, ValueType, ClientDataType &),
                ClientDataType & data);

/*
 * Method: iterator
 * Usage: iter = map.iterator();
 * -----------------------------
 * This method creates an iterator that allows the client to
 * iterate through the keys in this map.  The map abstraction
 * makes no guarantees about the order in which keys are returned.
 *
 * The idiomatic code for accessing elements using an iterator is
 * to create the iterator from the collection and then enter a loop
 * that calls next() while hasNext() is true, like this:
 *
 *     Map<int>::Iterator iter = map.iterator();
 *     while (iter.hasNext()) {
 *         string key = iter.next();
 *         . . .
 *     }
 *
 * This pattern can be abbreviated to the following more readable form:
 *
 *     foreach (string key in map) {
 *         . . .
 *     }
 *
 * To avoid exposing the details of the class, the definition of the
 * Iterator class itself appears in the private/grid.h file.
 */
    Iterator iterator();

private:

//#include "private/map.h"
    /*
     * File: private/map.h
     * Last modified on Fri Jun  5 15:39:52 2009 by eroberts
     * -----------------------------------------------------
     * This file contains the private section of the map.h interface.
     * This portion of the class definition is taken out of the map.h
     * header so that the client need not have to see all of these
     * details.
     */

    public:

    /*
     * Legacy method: add
     * ------------------
     * Old name for put method.  This name was changed for compatibility
     * with Java and to emphasize the symmetry between get and put.
     */
        void add(string key, ValueType value);

    /*
     * Legacy method: getValue
     * -----------------------
     * Old name for get method.  This name was changed for compatibility
     * with Java and to emphasize the symmetry between get and put.
     */
        ValueType getValue(string key);

    /*
     * Class: Map<ValType>::Iterator
     * ------------------------------
     * This interface defines a nested class within the Map template that
     * provides iterator access to the keys contained in the Map.
     */
        class Iterator : public FE_Iterator {
        public:
            Iterator();
            bool hasNext();
            string next();

        private:
            Iterator(Map *mp);
            Map *mp;
            int bucketIndex;
            void *cellPtr;
            long timestamp;
            void advanceToNextKey();
            friend class Map;
        };
        friend class Iterator;
        string foreachHook(FE_State & _fe);

    /*
     * Deep copying support
     * --------------------
     * This copy constructor and operator= are defined to make a
     * deep copy, making it possible to pass/return maps by value
     * and assign from one map to another. The entire contents of
     * the map, including all entries, are copied. Each map
     * entry is copied from the original map to the copy using
     * assignment (operator=). Making copies is generally avoided
     * because of the expense and thus, maps are typically passed by
     * reference, however, when a copy is needed, these operations
     * are supported.
     */
        const Map & operator=(const Map & rhs);
        Map(const Map & rhs);

    private:
        struct cellT {
            string key;
            ValueType value;
            cellT *next;
        };

        Vector<cellT *> buckets;
        int numEntries;
        long timestamp;

        void initBuckets(int nBuckets);
        void deleteBuckets(Vector<cellT *> & bucketsToDelete);
        int hash(string s);
        cellT *findCell(cellT *head, string key, cellT **prev = NULL);
        void expandAndRehash();
        void copyOtherEntries(const Map & rhs);


};

//#include "private/map.cpp"
/*
 * File: private/map.cpp
 * Last modified on Thu Jun 11 12:56:31 2009 by eroberts
 * -----------------------------------------------------
 * This file contains the private section of the map.cpp interface.
 * Because of the way C++ compiles templates, this code must be
 * available to the compiler when it reads the header file.
 */

//#ifdef _map_h

/*
 * Implementation notes: Map class
 * -------------------------------
 * In this map implementation, the entries are stored in a hashtable.
 * The hashtable keeps a vector of "buckets", where each bucket is a
 * linked list of elements that share the same hash code (i.e. hash
 * collisions are resolved by chaining). The buckets are dynamically
 * allocated so that we can change the the number of buckets (rehash)
 * when the load factor becomes too high. The map should provide O(1)
 * performance on the put/remove/get operations.
 */

template <typename ValueType>
Map<ValueType>::Map(int sizeHint) {
    if (sizeHint < 0) Error("Negative sizeHint given to Map constructor");
    initBuckets(sizeHint);
    timestamp = 0L;
}

template <typename ValueType>
Map<ValueType>::~Map() {
    deleteBuckets(buckets);
}

template <typename ValueType>
int Map<ValueType>::size() {
    return numEntries;
}

template <typename ValueType>
bool Map<ValueType>::isEmpty() {
    return size() == 0;
}

template <typename ValueType>
void Map<ValueType>::put(string key, ValueType value) {
    (*this)[key] = value;
}

template <typename ValueType>
void Map<ValueType>::remove(string key) {
    int hashCode = hash(key);
    cellT *prev;
    cellT *found = findCell(buckets[hashCode], key, &prev);
    if (found != NULL) {
        if (prev != NULL) {
            prev->next = found->next;
        } else {
            buckets[hashCode] = found->next;
        }
        numEntries--;
        delete found;
    }
    timestamp++;
}

template <typename ValueType>
void Map<ValueType>::clear() {
    deleteBuckets(buckets);
    numEntries = 0;
    timestamp++;
}

template <typename ValueType>
bool Map<ValueType>::containsKey(string key) {
    int hashCode = hash(key);
    return findCell(buckets[hashCode], key) != NULL;
}

template <typename ValueType>
ValueType Map<ValueType>::get(string key) {
    if (containsKey(key)) return (*this)[key];
    Error("Attempt to get value for key which is not contained in map.");
    return ValueType();
}

template <typename ValueType>
ValueType & Map<ValueType>::operator[](string key) {
    int hashCode = hash(key);
    cellT *cp = findCell(buckets[hashCode], key);
    if (cp == NULL) {
        if (numEntries > buckets.size()*2) expandAndRehash();
        hashCode = hash(key);
        cp = new cellT;
        cp->key = key;
        cp->value = ValueType();
        cp->next = buckets[hashCode];
        buckets[hashCode] = cp;
        numEntries++;
        timestamp++;
    }
    return cp->value;
}

template <typename ValueType>
const Map<ValueType> &Map<ValueType>::operator=(const Map & rhs) {
    if (this != &rhs) {
        deleteBuckets(buckets);
        copyOtherEntries(rhs);
        timestamp = 0L;
    }
    return *this;
}

template <typename ValueType>
Map<ValueType>::Map(const Map & rhs) {
    copyOtherEntries(rhs);
    timestamp = 0L;
}

template <typename ValueType>
void Map<ValueType>::add(string key, ValueType value) {
    put(key, value);
}

template <typename ValueType>
ValueType Map<ValueType>::getValue(string key) {
    return get(key);
}

template <typename ValueType>
template <typename ClientData>
void Map<ValueType>::mapAll(void (*fn)(string, ValueType, ClientData &),
                            ClientData & data) {
    long t0 = timestamp;
    for (int i = 0 ; i < buckets.size(); i++) {
        for (cellT *cp = buckets[i]; cp != NULL; cp = cp->next) {
            fn(cp->key, cp->value, data);
            if (t0 != timestamp) {
                Error("mapAll: Map structure changed");
            }
        }
    }
}

template <typename ValueType>
void Map<ValueType>::mapAll(void (*fn)(string key, ValueType value)) {
    long t0 = timestamp;
    for (int i = 0 ; i < buckets.size(); i++) {
        for (cellT *cp = buckets[i]; cp != NULL; cp = cp->next) {
            fn(cp->key, cp->value);
            if (t0 != timestamp) {
                Error("mapAll: Map structure changed");
            }
        }
    }
}

/*
 * Private method: deleteBuckets
 * Usage: deleteBuckets(buckets);
 * ------------------------------
 * This function deletes all the cells in the linked lists contained in vector.
 */

template <typename ValueType>
void Map<ValueType>::deleteBuckets(Vector<cellT *> & b) {
    for (int i = 0; i < b.size(); i++) {
        while (b[i] != NULL) {
            cellT *next = b[i]->next;
            delete b[i];
            b[i] = next;
        }
    }
}

/*
 * Private method: findCell
 * Usage: cp = findCell(cp, key, &prev);
 * -------------------------------------
 * This function finds a cell in the chain beginning at cp that
 * matches key.  If a match is found, a pointer to that cell is
 * returned.  If no match is found, the function returns NULL.
 * The optional third argument is a pointer to the previous cell
 * pointer, which the client may need if attempting to splice out
 * the found cell. If not specified, NULL is the default value.
 */

template <typename ValueType>
typename Map<ValueType>::cellT
         *Map<ValueType>::findCell(cellT *cp, string key, cellT **prevByRef) {
    cellT *prev = NULL;
    while (cp != NULL && key != cp->key) {
        prev = cp;
        cp = cp->next;
    }
    if (prevByRef != NULL) *prevByRef = prev;
    return cp;
}

/*
 * Private method: hash
 * Usage: bucket = hash(key);
 * --------------------------
 * This function takes the key and uses it to derive a hash code,
 * which is an integer in the range [0, buckets.size() - 1].  The hash
 * code is computed using a method called linear congruence.
 */

template <typename ValueType>
int Map<ValueType>::hash(string s) {
    const long Multiplier = -1664117991;
    unsigned long hashcode = 0;
    for (string::size_type i = 0; i < s.length(); i++) {
        hashcode = hashcode * Multiplier + s[i];
    }
    return hashcode % buckets.size();
}

/*
 * Private method: expandAndRehash
 * Usage: expandAndRehash();
 * -------------------------
 * This method is used to increase the number of buckets in the map
 * and then rehashes all existing entries and adds them into new buckets.
 * This operation is used when the load factor (i.e. the number of cells
 * per bucket) has increased enough to warrant this O(N) operation to
 * enlarge and redistribute the entries.
 */

template <typename ValueType>
void Map<ValueType>::expandAndRehash() {
    Vector<cellT *>oldBuckets = buckets;
    initBuckets(oldBuckets.size()*2 + 1);
    for (int i = 0; i < oldBuckets.size(); i++) {
        for (cellT *cp = oldBuckets[i]; cp != NULL; cp = cp->next) {
            put(cp->key, cp->value);
        }
    }
    deleteBuckets(oldBuckets);
}

/*
 * Private method: initBuckets
 * Usage: initBuckets(101);
 * -----------------------
 * This methods sets up the vector of buckets to have nBuckets
 * entries, each NULL. If asked to make empty vector, makes one bucket
 * just to simplify handling elsewhere.
 */

template <typename ValueType>
void Map<ValueType>::initBuckets(int nBuckets) {
    if (nBuckets == 0) nBuckets = 1;
    buckets = Vector<cellT *>(nBuckets);
    for (int i = 0; i < nBuckets; i++) {
        buckets.add(NULL);
    }
    numEntries = 0;
}

template <typename ValueType>
static void AddToMap(string key, ValueType val, Map<ValueType> & map) {
    map.put(key, val);
}

/*
 * Private method: copyOtherEntries
 * Usage: copyOtherEntries(otherMap);
 * ----------------------------------
 * This methods adds a copy of all entries from the other map to
 * this one.
 *
 * Implementation note: We aren't really adhering to const. Even though
 * the methods invoked on rhs don't modify it, they aren't marked const,
 * and thus trigger compiler problems. We cast away const-ness to avoid
 * this erroneous complaints. Sigh.
 */

template <typename ValueType>
void Map<ValueType>::copyOtherEntries(const Map & constRhs) {
    Map & rhs = const_cast<Map &>(constRhs);
    initBuckets(rhs.size());
    rhs.mapAll< Map<ValueType> >(AddToMap, *this);
}

/*
 * Map::Iterator class implementation
 */

template <typename ValueType>
Map<ValueType>::Iterator::Iterator() {
    mp = NULL;
}

template <typename ValueType>
typename Map<ValueType>::Iterator Map<ValueType>::iterator() {
    return Iterator(this);
}

template <typename ValueType>
Map<ValueType>::Iterator::Iterator(Map *mapptr) {
    mp = mapptr;
    bucketIndex = -1;
    cellPtr = NULL;
    timestamp = mp->timestamp;
    advanceToNextKey();
}

template <typename ValueType>
bool Map<ValueType>::Iterator::hasNext() {
    if (mp == NULL) Error("hasNext called on uninitialized iterator");
    if (timestamp != mp->timestamp) {
        Error("Map structure has been modified");
    }
    return cellPtr != NULL;
}

template <typename ValueType>
string Map<ValueType>::Iterator::next() {
    if (mp == NULL) Error("next called on uninitialized iterator");
    if (!hasNext()) {
        Error("Attempt to get next from iterator"
              " where hasNext() is false");
    }
    string result = ((cellT *) cellPtr)->key;
    advanceToNextKey();
    return result;
}

template <typename ValueType>
void Map<ValueType>::Iterator::advanceToNextKey() {
    cellT *cp = (cellT *) cellPtr;
    if (cp != NULL) cp = cp->next;
    while (cp == NULL && ++bucketIndex < mp->buckets.size()) {
        cp = mp->buckets[bucketIndex];
    }
    cellPtr = (void *) cp;
}

template <typename ValueType>
string Map<ValueType>::foreachHook(FE_State & fe) {
    if (fe.state == 0) fe.iter = new Iterator(this);
    if (((Iterator *) fe.iter)->hasNext()) {
        fe.state = 1;
        return ((Iterator *) fe.iter)->next();
    } else {
        fe.state = 2;
        return "";
    }
}

//#endif


//#endif
/*
 * File: grid.h
 * Last modified on Fri Jun  5 15:37:17 2009 by eroberts
 *      modified on Tue Jan  2 13:40:51 2007 by zelenski
 * -----------------------------------------------------
 * This interface defines a class template to store a homogeneous 2-D
 * indexed collection. The basic operations are similar to those
 * on C++ built-in multi-dimensional arrays with the added features of
 * dynamic resizing, deep copying, and bounds-checking on indexes.
 *
 * Here is some sample code showing use of a Grid of strings:
 *
 *      Grid<string> g(4, 6);  <= creates 4x6 grid, each string empty
 *
 *      g[0][2] = "blue";      <= can set elemes using [] or setAt
 *      g.setAt(2, 3, "red");
 *
 *      for (int row = 0; row < g.numRows(); row++) {
 *          for (int col = 0; col < g.numCols(); col++) {
 *               cout << g[row][col] << " ";
 *          }
 *  }
 *
 * Access to individual elements in the grid is provided via the
 * setAt/getAt methods, as well as an overloaded operator[].
 * Either refers to cells by row/col location; indexes start at 0 in
 * each dimension.
 */

//#ifndef _grid_h
//#define _grid_h

//#include "genlib.h"
//#include "strutils.h"
//#include "foreach.h"

/*
 * Class: Grid
 * ------------
 * The class Grid stores an indexed, two-dimensional collection.
 * It is supplied as a class template. The client specializes the grid
 * to hold values of a specific type. Because the class is defined
 * with private data members, clients have no access to the underlying
 * data members and can only manipulate a grid object through
 * its public methods.
 */

template <typename ElemType>
class Grid {

public:

/* Forward references */
    class GridRow;
    class Iterator;

/*
 * Constructor: Grid
 * Usage: Grid<bool> grid;
 *        Grid<string> *gp = new Grid<string>;
 * -------------------------------------------
 * This no-argument constructor initializes a new empty grid with
 * 0 rows and 0 cols.
 */
    Grid();

/*
 * Constructor: Grid
 * Usage: Grid<bool> grid(10, 20)
 * Grid<string> *gp = new Grid<string>(10, 20);
 * --------------------------------------------
 * This two-argument constructor initializes a new grid with the
 * specified number of rows and cols. Each element in the grid has
 * value equal to the default for that element type (e.g. for strings
 * it would be empty string, for ints, the default value is uninitialized).
 * Raises an error if numRows or numCols is negative.
 */
    Grid(int numRows, int numCols);

/*
 * Destructor: ~Grid
 * Usage: delete gp;
 * -----------------
 * The destructor deallocates storage associated with this grid.
 */
    ~Grid();

/*
 * Methods: numRows, numCols
 * Usage: nRows = grid.numRows();
 * ------------------------------
 * These methods returns the number of rows or columns in
 * this grid.
 */
    int numRows();
    int numCols();

/*
 * Method: resize
 * Usage: grid.resize(5, 10);
 * --------------------------
 * This method sets the number of rows and columns in this
 * grid to the specified values. Any previous grid contents are
 * discarded.   Each element in the  resized grid has value equal
 * to the default for that element type. Raises an error if numRows
 * or numCols is negative.
 */
    void resize(int numRows, int numCols);

/*
 * Method: getAt
 * Usage: val = grid.getAt(3, 10);
 * -------------------------------
 * This method returns the element at specified row/col
 * location in this grid. Locations are indexed starting from 0.
 * Raises an error if row is outside range [0, numRows()-1] or if
 * col is outside range [0, numCols()-1].
 */
    ElemType getAt(int row, int col);

/*
 * Method: setAt
 * Usage: grid.setAt(3, 10, value);
 * --------------------------------
 * This method replaces the element at the specified
 * row/col location in this grid with a new value.  The previous
 * value at that location is overwritten with the new value.
 * Raises an error if row is outside the range [0, numRows()-1]
 * or if col is outside the range [0, numCols()-1].
 */
    void setAt(int row, int col, ElemType value);

/*
 * Method: inBounds
 * Usage: if (grid.inBounds(row, col);
 * -----------------------------------
 * This method returns true if the specified row and column position
 * are inside the bounds of the grid.
 */
    bool inBounds(int row, int col);

/*
 * Method: operator[]
 * Usage: grid[0][0] = grid[1][1];
 * -------------------------------
 * This method overloads [] to select elements from this grid.
 * This extension allows the client to use C/Java-like notation
 * to get/set individual elements. Returns a reference to the
 * element to allow in-place modification of values. Raises an
 * error if row is outside the range [0, numGridRows()-1] or if col is
 * outside the range [0, numCols()-1].
 */
    GridRow operator[](int row);

/*
 * SPECIAL NOTE: mapping/iteration support
 * ---------------------------------------
 * The Grid class supports both a mapping operation and an iterator which
 * allow the client access to all elements one by one.  In general,
 * these are intended for _viewing_ elements and can behave
 * unpredictably if you attempt to modify the grid's contents during
 * mapping/iteration.
 */

/*
 * Method: mapAll
 * Usage: grid.mapAll(Print);
 * --------------------------
 * This method iterates through this grid's contents
 * and calls the function fn once for each element.
 */
    void mapAll(void (*fn)(ElemType elem));

/*
 * Method: mapAll
 * Usage: grid.mapAll(PrintToFile, outputStream);
 * ----------------------------------------------
 * This method iterates through this grid's contents
 * and calls the function fn once for each element, passing
 * the element and the client's data. That data can be of whatever
 * type is needed for the client's callback.
 */
    template <typename ClientDataType>
    void mapAll(void (*fn)(ElemType elem, ClientDataType & data),
                ClientDataType & data);

/*
 * Method: iterator
 * Usage: iter = grid.iterator();
 * ------------------------------
 * This method creates an iterator that allows the client to
 * iterate through the elements in this grid.  The elements are
 * returned in row-major order.
 *
 * The idiomatic code for accessing elements using an iterator is
 * to create the iterator from the collection and then enter a loop
 * that calls next() while hasNext() is true, like this:
 *
 *     Grid<int>::Iterator iter = grid.iterator();
 *     while (iter.hasNext()) {
 *         int elem = iter.next();
 *         . . .
 *     }
 *
 * This pattern can be abbreviated to the following more readable form:
 *
 *     foreach (int elem in grid) {
 *         . . .
 *     }
 *
 * To avoid exposing the details of the class, the definition of the
 * Iterator class itself appears in the private/grid.h file.
 */
    Iterator iterator();

private:

//#include "private/grid.h"
    /*
     * File: private/grid.h
     * Last modified on Fri Jun  5 15:40:23 2009 by eroberts
     * -----------------------------------------------------
     * This file contains the private section of the grid.h interface.
     * This portion of the class definition is taken out of the grid.h
     * header so that the client need not have to see all of these
     * details.
     */

    public:

    /*
     * Legacy method: operator()
     * Usage: grid(0, 0) = grid(1, 1);
     * -------------------------------
     * This method overloads () to access elements from this grid.
     * It has been superseded by the [] operator and is not used in
     * new code.
     */
        ElemType & operator()(int row, int col);

    /*
     * Class: Grid<ValType>::GridRow
     * -----------------------------
     * This section of the code defines a nested class within the Grid template
     * that makes it possible to use traditional subscripting on Grid values.
     */
        class GridRow {
        public:
            GridRow();
            ElemType & operator[](int col);

        private:
            GridRow(Grid *gridRef, int index);
            Grid *gp;
            int row;
            friend class Grid;
        };
        friend class GridRow;

    /*
     * Class: Grid<ElemType>::Iterator
     * -------------------------------
     * This interface defines a nested class within the Grid template that
     * provides iterator access to the Grid contents.
     */
        class Iterator : public FE_Iterator {
        public:
            Iterator();
            bool hasNext();
            ElemType next();

        private:
            Iterator(Grid *gridRef);
            Grid *gp;
            int curRow;
            int curCol;
            long timestamp;
            friend class Grid;
        };
        friend class Iterator;
        ElemType foreachHook(FE_State & _fe);

    /*
     * Deep copying support
     * --------------------
     * This copy constructor and operator= are defined to make a
     * deep copy, making it possible to pass/return grids by value
     * and assign from one grid to another. The entire contents of
     * the grid, including all elements, are copied. Each grid
     * element is copied from the original grid to the copy using
     * assignment (operator=). Making copies is generally avoided
     * because of the expense and thus, grids are typically passed by
     * reference, however, when a copy is needed, these operations
     * are supported.
     */
        const Grid & operator=(const Grid & rhs);
        Grid(const Grid & rhs);

    private:

        ElemType *elements;
        int nRows, nCols;
        long timestamp;

        void checkRange(int row, int col);
        void copyContentsFrom(const Grid & other);

};

//#include "private/grid.cpp"
/*
 * File: private/grid.cpp
 * Last modified on Fri Jun  5 16:21:12 2009 by eroberts
 * -----------------------------------------------------
 * This file contains the implementation of the grid.h interface.
 * Because of the way C++ compiles templates, this code must be
 * available to the compiler when it reads the header file.
 */

//#ifdef _grid_h

/*
 * Grid class implementation
 * ---------------------------
 * The Grid is internally managed as a dynamic array of elements.  The array
 * itself is one-dimensional, the logical separation into rows and columns
 * is done manually.  The layout is in row-major order, which is to say that
 * the first entire row is laid out contiguously, followed by the entire
 * next row and so on. All access is bounds-checked for safety.
 */

template <typename ElemType>
Grid<ElemType>::Grid() {
    nRows = 0;
    nCols = 0;
    timestamp = 0L;
    elements = NULL;
}

template <typename ElemType>
Grid<ElemType>::Grid(int numRows, int numCols) {
    elements = NULL;
    timestamp = 0L;
    resize(numRows, numCols);
}

template <typename ElemType>
Grid<ElemType>::~Grid() {
    delete[] elements;
}

template <typename ElemType>
int Grid<ElemType>::numRows() {
    return nRows;
}

template <typename ElemType>
int Grid<ElemType>::numCols() {
    return nCols;
}

template <typename ElemType>
void Grid<ElemType>::resize(int numRows, int numCols) {
    if (numRows < 0 || numCols < 0) {
        Error("Attempt to resize grid to invalid size ("
              + IntegerToString(numRows) + ", "
              + IntegerToString(numCols) + ")");
    }
    if (elements) delete[] elements;
    nRows = numRows;
    nCols = numCols;
    elements = new ElemType[nRows * nCols];
    timestamp++;
}

template <typename ElemType>
ElemType Grid<ElemType>::getAt(int row, int col) {
    return (*this)(row, col);
}

template <typename ElemType>
void Grid<ElemType>::setAt(int row, int col, ElemType value) {
    (*this)(row, col) = value;
}

template <typename ElemType>
bool Grid<ElemType>::inBounds(int row, int col) {
    return row >= 0 && col >= 0 && row < nRows && col < nCols;
}

template <typename ElemType>
ElemType &Grid<ElemType>::operator()(int row, int col) {
    checkRange(row,col);
    return elements[(row * nCols) + col];
}

template <typename ElemType>
typename Grid<ElemType>::GridRow Grid<ElemType>::operator[](int row) {
    return GridRow(this, row);
}

template <typename ElemType>
const Grid<ElemType> & Grid<ElemType>::operator=(const Grid & rhs) {
    if (this != &rhs) {
        delete[] elements;
        copyContentsFrom(rhs);
        timestamp = 0L;
    }
    return *this;
}

template <typename ElemType>
Grid<ElemType>::Grid(const Grid & rhs) {
    copyContentsFrom(rhs);
    timestamp = 0L;
}

template <typename ElemType>
void Grid<ElemType>::checkRange(int row, int col) {
    if (row < 0 || row >= numRows() || col < 0 || col >= numCols()) {
        Error("Attempt to access location ("
              + IntegerToString(row) + ", " + IntegerToString(col)
              + ") in a grid of size (" + IntegerToString(numRows())
              + ", " + IntegerToString(numCols()) + ")");
    }
}

template <typename ElemType>
void Grid<ElemType>::copyContentsFrom(const Grid & other) {
    nRows = other.nRows;
    nCols = other.nCols;
    elements = new ElemType[nRows * nCols];
    for (int i = 0; i < nRows * nCols; i++) {
        elements[i] = other.elements[i];
    }
}

template <typename ElemType>
void Grid<ElemType>::mapAll(void (*fn)(ElemType)) {
    long t0 = timestamp;
    for (int i = 0; i < nRows * nCols; i++) {
        if (timestamp != t0) {
            Error("Grid structure has been modified");
        }
        fn(elements[i]);
    }
}

template <typename ElemType>
template <typename ClientDataType>
void Grid<ElemType>::mapAll(void (*fn)(ElemType, ClientDataType&),
                            ClientDataType & data) {
    long t0 = timestamp;
    for (int i = 0; i < nRows * nCols; i++) {
        if (timestamp != t0) {
            Error("Grid structure has been modified");
        }
        fn(elements[i], data);
    }
}

/*
 * Grid::Iterator class implementation
 * ----------------------------------
 * The Iterator for Grid maintains a pointer to the original Grid and
 * an index into that vector that identifies the next element to return.
 */

template <typename ElemType>
Grid<ElemType>::Iterator::Iterator() {
    gp = NULL;
}

template <typename ElemType>
typename Grid<ElemType>::Iterator Grid<ElemType>::iterator() {
    return Iterator(this);
}

template <typename ElemType>
Grid<ElemType>::Iterator::Iterator(Grid *gridRef) {
    gp = gridRef;
    curRow = 0;
    curCol = 0;
    timestamp = gp->timestamp;
}

template <typename ElemType>
bool Grid<ElemType>::Iterator::hasNext() {
    if (gp == NULL) Error("hasNext called on uninitialized iterator");
    if (timestamp != gp->timestamp) {
        Error("Grid structure has been modified");
    }
    return curRow < gp->numRows() && curCol < gp->numCols();
}

template <typename ElemType>
ElemType Grid<ElemType>::Iterator::next() {
    if (gp == NULL) Error("next called on uninitialized iterator");
    if (!hasNext()) {
        Error("Attempt to get next from iterator"
              " where hasNext() is false");
    }
    int row = curRow;
    int col = curCol++;
    if (curCol == gp->numCols()) {
        curCol = 0;
        curRow++;
    }
    return (*gp)(row, col);
}

template <typename ElemType>
ElemType Grid<ElemType>::foreachHook(FE_State & fe) {
    if (fe.state == 0) fe.iter = new Iterator(this);
    if (((Iterator *) fe.iter)->hasNext()) {
        fe.state = 1;
        return ((Iterator *) fe.iter)->next();
    } else {
        fe.state = 2;
        return ElemType();
    }
}

/* GridRow implementation */

template <typename ElemType>
Grid<ElemType>::GridRow::GridRow() {
    /* Empty */
}

template <typename ElemType>
Grid<ElemType>::GridRow::GridRow(Grid *gridRef, int index) {
    gp = gridRef;
    row = index;
}

template <typename ElemType>
ElemType & Grid<ElemType>::GridRow::operator[](int col) {
    return (*gp)(row,col);
}

//#endif

//#endif
/*
 * File: lexicon.h
 * ---------------
 * Defines the Lexicon class.
 * Modified Tue Oct 10 20:47:22 PDT 2006 jzelenski
 *
 * Last modified 22-Sep-2011 by Colin
 * All 4-byte values are now declared int, not long (to avoid problems on 64-bit OSs).
 *
 */

//#ifndef _lexicon_h
//#define _lexicon_h

#include <string>
//#include "genlib.h"
#include <set>

/*
 * Class: Lexicon
 * --------------
 * This class is used to represent a lexicon, or word list. The main difference
 * between the lexicon abstraction and a map or dictionary container is that
 * the lexicon does not provide any mechanism for storing definitions of words;
 * the lexicon contains only words, with no associated information.  The lexicon
 * supports very efficient lookup operations for words and prefixes. You can
 * populate the lexicon by adding words one at a time or by constructing a lexicon
 * with words read from a file. Here is sample use of a Lexicon object:
 *
 *    Lexicon lex("lexicon.dat");    // read words from lexicon.dat file
 *    lex.add("doughnut");
 *  if (lex.containsPrefix("fru") || lex.containsWord("ball"))
 *        ...
 */

#include <cctype>

class Lexicon {

  public:
    
    /*
     * Constructor: Lexicon
     * Usage: Lexicon lex;
     *        Lexicon *lp = new Lexicon;
     * ---------------------------------
     * The constructor initializes a new empty lexicon.
     */
    Lexicon();
    
    /*
     * Constructor: Lexicon
     * Usage: Lexicon lex("lexicon.dat");
     *        Lexicon *lp = new Lexicon("lexicon.txt");
     * -----------------------------------------------
     * The constructor initializes a new lexicon which is populated with
     * the words read from the specified file.  The file is expected to
     * be either a special special binary format that represents a saved
     * lexicon or a plain text file of words, one word per line. The
     * constructor reads the file and adds all of its words to this lexicon.
     * The file must be in the same folder as the program to be found. If
     * the file doesn't exist or is malformed, Error is called to exit the program.
     */
    Lexicon(string filename);


   /*
     * Destructor: ~Lexicon
     * Usage: delete lp;
     * ------------------
     * The destructor deallocates any storage associated with the lexicon.
     */
    ~Lexicon();
    
    
   /*
    * Member function: size
    * Usage: count = lex.size();
    * --------------------------
    * This member function returns the number of words contained in this lexicon.
    */
    int size();
    
   /*
    * Member function: isEmpty
    * Usage: if (lex.isEmpty())...
    * --------------------------
    * This member function returns true if this lexicon contains no words, false otherwise.
    */
    bool isEmpty();

    
   /*
    * Member function: add
    * Usage: lex.add("computer");
    * ---------------------------
    * This member function adds the specified word to this lexicon.
    */
    void add(string word);
     
   /*
    * Member function: addWordsFromFile
    * Usage: lex.addWordsFromFile("words.txt");
    * -----------------------------------------
    * This member function reads the file and adds all of its words to this lexicon.
    * The file is expected to be either a special special binary format that represents
    * a saved lexicon or a plain text file of words, one word per line.
    * The file must be in the same folder as the program to be found. If
    * the file doesn't exist or is malformed, Error is called to exit the program.
    */
    void addWordsFromFile(string filename);


   /*
    * Member function: containsWord
    * Usage: if (lex.containsWord("happy"))...
    * ----------------------------------------
    * This member function returns true if word is contained in this lexicon,
    * false otherwise.  Words are considered case-insensitively, "zoo" is the
    * same as "ZOO" or "zoo".
    */
    bool containsWord(string word);
    
    
   /*
    * Member function: containsPrefix
    * Usage: lex.containsPrefix("mo");
    * --------------------------------
    * This member function returns true if any words in this lexicon begin with
    * prefix, false otherwise.  A word is defined to be a prefix of itself
    * and the empty string is a prefix of everything. Prefixes are considered
    * case-insensitively, "mo" is a prefix of "MONKEY" or "Monday".
    */
    bool containsPrefix(string prefix);


   /*
    * Member function: clear
    * Usage: lex.clear();
    * -------------------
    * This member function removes all words from this lexicon. The lexicon
    * will be empty after being cleared.
    */
    void clear();
    

    /*
     * SPECIAL NOTE: mapping support
     * -----------------------------
     * The lexicon supports a mapping operation which allows the client to access
     * words one by one.  In general, mapping is intended for _viewing_ words
     * and can behave unpredictably if you attempt to modify the lexicon's contents
     * during mapping.
     */

    /*
     * Member function: mapAll
     * Usage: lexicon.mapAll(PrintToFile, outputStream);
     * -------------------------------------------------
     * This member function iterates through this lexicon
     * and calls the function fn once for each word, passing
     * the word and the client's data. That data can be of whatever
     * type is needed for the client's callback.
     */
    template <typename ClientDataType>
      void mapAll(void (fn)(string word, ClientDataType &), ClientDataType &data);


    /*
     * Deep copying support
     * --------------------
     * This copy constructor and operator= are defined to make a
     * deep copy, making it possible to pass/return lexicons by value
     * and assign from one lexicon to another. The entire contents of
     * the lexicon, including all words, are copied. Making copies is
     * generally avoided because of the expense and thus, lexicons are
     * typically passed by reference, however, when a copy is needed,
     * these operations are supported.
     */
    Lexicon(const Lexicon &rhs);
    const Lexicon & operator=(const Lexicon &rhs);
              
                
  private:
    /* Everything from here to the end of the class is private, so
     * not accessible or intended for use for the client */

    
#ifdef _MSC_VER
#define LITTLE_ENDIAN 1
#define BYTE_ORDER LITTLE_ENDIAN
#endif

    struct Edge {
#if defined(BYTE_ORDER) && BYTE_ORDER == LITTLE_ENDIAN
        unsigned int letter:5;
        unsigned int lastEdge:1;
        unsigned int accept:1;
        unsigned int unused:1;
        unsigned int children:24;
#else
        unsigned int children:24;
        unsigned int unused:1;
        unsigned int accept:1;
        unsigned int lastEdge:1;
        unsigned int letter:5;
#endif
    };
    
    Edge *edges, *start;
    int numEdges, numDawgWords;
    std::set<string> otherWords;

    Edge *findEdgeForChar(Edge *children, char ch);
    Edge *traceToLastEdge(const string & s);
    void readBinaryFile(string filename);
    template <typename ClientDataType>
      void recMapAll(Edge *edge, bool first, string soFar, void (fn)(string, ClientDataType &), ClientDataType &data);

    unsigned int charToOrd(char ch) { return ((unsigned int)(tolower(ch) - 'a' + 1)); }
    char ordToChar(unsigned int ord) { return ((char)(ord - 1 + 'a')); }
    void copyContentsFrom(const Lexicon &rhs);
    
};


/*
 * Because of the way C++ templates are compiled, we must put the implementation for
 * the mapping operation here in the header file. This is a bit quirky and seems to
 * contradict the principles of encapsulation and abstraction. As a client of this class,
 * you don't need to know anything about the internals and shouldn't depend on any
 * implementation details. In fact, you probably should just stop reading right here!
 */


template <typename ClientDataType>
  void Lexicon::recMapAll(Edge *edge, bool first, string soFar, void (fn)(string word, ClientDataType &), ClientDataType &clientData)
    {
        if (!edge) return;
        Edge *curEdge;
        if (first) {
            curEdge = edge;
        } else {
            soFar += ordToChar(edge->letter);
            if (edge->accept) fn(soFar, clientData);
            if (!edge->children) return;
            curEdge = &edges[edge->children];
        }
        while (true) {
            recMapAll(curEdge, false, soFar, fn, clientData);
            if (curEdge->lastEdge) break;
            curEdge++;
        }
    }
    
template <typename ClientDataType>
  void Lexicon::mapAll(void (fn)(string word, ClientDataType &), ClientDataType &clientData)
    {
        recMapAll(start, true, "", fn, clientData);    // map over dawg
        for (set<string>::iterator itr = otherWords.begin(); itr != otherWords.end(); itr++)
            fn(*itr, clientData);                    // map over other set
    }


//#endif
FE_Iterator::FE_Iterator()
{
    // Do what??
    // Just hope this base class will overridden, I guess....
}

FE_Iterator::~FE_Iterator()
{
    // as constructor...
}


/*
 * Class: FE_State
 * ---------------
 * This class is used to maintain the state of the foreach processing.
 * The class itself is essentially private, but the implementations in
 * the different classes use the fields directly.
 *
 */

// Public instance variables:
// int state;
// FE_Iterator *iter;

FE_State::FE_State()
{
    state = 0;
    iter = new FE_Iterator;
}

FE_State::~FE_State()
{
    delete iter;
}

/*
 * File: random.h
 * Version: 1.1CPP
 * Last modified on Wed Apr  1 07:57:04 2009 by eroberts
 *      modified on Wed Sep 18 13:32:23 2002 by zelenski
 * -----------------------------------------------------
 * This interface provides several functions for generating
 * pseudo-random numbers.
 */

//#ifndef _random_h
//#define _random_h

/*
 * Function: Randomize
 * Usage: Randomize();
 * -------------------
 * This function sets the random seed so that the random sequence
 * is unpredictable.   If this function is not called, the other
 * functions will return the same values on each run. During the
 * debugging phase, it is best not to call this function, so that
 * program behavior is repeatable.
 */

void Randomize();

/*
 * Function: RandomInteger
 * Usage: n = RandomInteger(low, high);
 * ------------------------------------
 * This function returns a random integer in the range low to high,
 * inclusive.
 */

int RandomInteger(int low, int high);

/*
 * Function: RandomReal
 * Usage: d = RandomReal(low, high);
 * ---------------------------------
 * This function returns a random real number in the half-open
 * interval [low .. high), meaning that the result is always
 * greater than or equal to low but strictly less than high.
 */

double RandomReal(double low, double high);

/*
 * Function: RandomChance
 * Usage: if (RandomChance(p)) . . .
 * ---------------------------------
 * The RandomChance function returns true with the probability
 * indicated by p, which should be a floating-point number between
 * 0 (meaning never) and 1 (meaning always).  For example, calling
 * RandomChance(.30) returns true 30 percent of the time.
 */

bool RandomChance(double p);

/*
 * Function: SetRandomSeed
 * Usage: SetRandomSeed(seed);
 * ---------------------------
 * This function sets the internal random number seed to the
 * specified value.  Clients can use this function to set a
 * specific starting point for the pseudorandom sequence.
 */

void SetRandomSeed(int seed);

//#endif
/*
 * File: random.cpp
 * -----------------
 * This file implements the random.h interface.
 */

#include <cstdlib>
#include <ctime>
//#include "random.h"

/*
 * Function: RandomInteger
 * -----------------------
 * This function begins by using rand to select an integer
 * in the interval [0, RAND_MAX] and then converts it to the
 * desired range by applying the following steps:
 *
 * 1. Normalize the value to a real number in the interval [0, 1)
 * 2. Scale the resulting value to the appropriate range size
 * 3. Truncate the scaled value to an integer
 * 4. Translate the integer to the appropriate starting point
 */

int RandomInteger(int low, int high) {
    double d = double(rand()) / (double(RAND_MAX) + 1);
    int k = int(d * (high - low));
    return low + k;
}

/*
 * Function: RandomReal
 * --------------------
 * The implementation of RandomReal is similar to that
 * of RandomInteger, without the truncation step.
 */

double RandomReal(double low, double high) {
    double d = double(rand()) / (double(RAND_MAX) + 1);
    return low + d * (high - low);
}

/*
 * Function: RandomChance
 * ----------------------
 * This function uses RandomReal to generate a real number
 * in the interval [0, 1) and then compares that value to p.
 */

bool RandomChance(double p) {
    return RandomReal(0, 1) < p;
}

/*
 * Function: Randomize
 * -------------------
 * This function operates by setting the random number
 * seed to the current time. The srand function is
 * provided by the <cstdlib> library and requires an
 * integer argument. The time function is exported by
 * the <ctime> interface.
 */

void Randomize() {
    srand(int(time(NULL)));
}



/*
 * File: set.h
 * Last modified on Thu Jun 11 09:17:43 2009 by eroberts
 *      modified on Tue Jan  2 14:34:06 2007 by zelenski
 * -----------------------------------------------------
 * This interface file contains the Set class template, a
 * collection for efficiently storing a set of distinct elements.
 */

//#ifndef _set_h
//#define _set_h

//#include "cmpfn.h"
/*
 * File: cmpfn.h
 * Last modified on Wed Sep 18 14:38:14 2002 by zelenski
 * -----------------------------------------------------
 * This interface exports a comparison function template.
 */

//#ifndef _cmpfn_h
//#define _cmpfn_h

/*
 * Function template: OperatorCmp
 * Usage:  int sign = OperatorCmp(val1, val2);
 * -------------------------------------------
 * This function template is a generic function to
 * compare two values using the built-in == and < operators.
 * It is supplied as a convenience for those situations
 * where a comparison function is required, and the type
 * has a built-in ordering that you would like to use.
 */
template <typename Type>
int OperatorCmp(Type one, Type two) {
    if (one == two) return 0;
    if (one < two) return -1;
    return 1;
}

//#endif

//#include "bst.h"
//#include "vector.h"
//#include "foreach.h"
/*
 * File: bst.h
 * Last modified on Fri Jun  5 15:08:03 2009 by eroberts
 *      modified on Tue Jan  2 14:23:33 2007 by zelenski
 * -----------------------------------------------------
 * This interface file contains the BST class template, an
 * implementation of a general binary search tree.
 *
 */

//#ifndef _bst_h
//#define _bst_h

//#include "genlib.h"
//#include "cmpfn.h"
//#include "stack.h"
//#include "foreach.h"

/*
 * Class: BST
 * ----------
 * This interface defines a class template for a binary search tree.
 * For maximum generality, the BST is supplied as a class template.
 * The element type is set by the client. The client specializes
 * the tree for specific type, e.g. BST<int> or BST<studentT>.
 * The one requirement on the element type is that the client must
 * supply a comparison fn that compares two elements (or be willing
 * to use the default comparison function that relies on < and ==).
 */

template <typename ElemType>
class BST {
public:

/* Forward references */
    class Iterator;

/*
 * Constructor: BST
 * Usage: BST<int> bst;
 *        BST<song> songs(CompareSong)
 *        BST<string> *bp = new BST<string>;
 * -----------------------------------------
 * The constructor initializes a new empty binary search tree.
 * The one argument is a comparison function, which is called
 * to compare data values.  This argument is optional, if not
 * given, the OperatorCmp function from cmpfn.h is used, which
 * applies the built-in operator < to its operands. If the
 * behavior of < on your ElemType is defined and sufficient,
 * you do not need to supply your own comparison function.
 */
    BST(int (*cmpFn)(ElemType one, ElemType two) = OperatorCmp);

/*
 * Destructor: ~BST
 * Usage: delete bp;
 * ------------------
 * The destructor deallocates storage for this tree.
 */
    ~BST();

/*
 * Method: size
 * Usage: count = bst.size();
 * --------------------------
 * This method returns the number of elements in
 * this tree.
 */
    int size();

/*
 * Method: isEmpty
 * Usage: if (bst.isEmpty())...
 * ----------------------------
 * This method returns true if this tree contains no
 * elements, false otherwise.
 */
    bool isEmpty();

/*
 * Method: find
 * Usage:  if (bst.find(key) != NULL) . . .
 * ----------------------------------------
 * This method applies the binary search algorithm to
 * find a particular key in this tree.  The second argument is
 * the key to use for comparison. If a node matching key appears
 * in the tree, find returns a pointer to the data in that node;
 * otherwise, find returns NULL.
 */
    ElemType *find(ElemType key);

/*
 * Method: add
 * Usage: bst.add(val);
 * --------------------
 * This method adds a new node to this tree. The elem
 * argument is compared with the data in existing nodes to find
 * the proper position. If a node with the same value already
 * exists, the contents are overwritten with the new copy and
 * false is returned.  If no matching node is found, a new node
 * is allocated and added to the tree, true is returned.
 */
    bool add(ElemType elem);

/*
 * Method: remove
 * Usage: bst.remove(key);
 -------------------------
 * This method removes a node in this tree that matches
 * the specified key. If a node matching key is found, the node
 * is removed from the tree and true is returned. If no match
 * is found, no changes are made and false is returned.
 */
    bool remove(ElemType key);

/*
 * Method: clear
 * Usage: bst.clear();
 * -------------------
 * This method removes all elements from this tree. The
 * tree is made empty and will have no nodes after being cleared.
 */
    void clear();

/*
 * Method: mapAll
 * Usage: bst.mapAll(Print);
 * -------------------------
 * This method iterates through this tree and calls the
 * function fn once for each element. The order is determined by an
 * InOrder walk of the tree.
 */
    void mapAll(void (*fn)(ElemType elem));

/*
 * Method: mapAll
 * Usage: bst.mapAll(PrintToFile, outputStream);
 * ---------------------------------------------
 * This method iterates through this tree con
 * and calls the function fn once for each element, passing
 * the element and the client's data. That data can be of
 * whatever type is needed for the client's callback. The order
 * of calls is determined by an InOrder walk of the tree.
 */
    template <typename ClientDataType>
    void mapAll(void (*fn)(ElemType elem, ClientDataType & data),
                    ClientDataType & data);

/*
 * Method: iterator
 * Usage: iter = bst.iterator();
 * -----------------------------
 * This method creates an iterator that allows the client to
 * iterate through the elements in this binary search tree.  The
 * order of elements produced by the iterator is that of an InOrder
 * walk of the tree.
 *
 * The idiomatic code for accessing elements using an iterator is
 * to create the iterator from the collection and then enter a loop
 * that calls next() while hasNext() is true, like this:
 *
 *     BST<string>::Iterator iter = bst.iterator();
 *     while (iter.hasNext()) {
 *         string key = iter.next();
 *         . . .
 *     }
 *
 * This pattern can be abbreviated to the following more readable form:
 *
 *     foreach (string key in bst) {
 *         . . .
 *     }
 *
 * To avoid exposing the details of the class, the definition of the
 * Iterator class itself appears in the private/bst.h file.
 */
    Iterator iterator();

private:

//#include "private/bst.h"
    /*
     * File: private/bst.h
     * Last modified on Fri Jun  5 15:40:43 2009 by eroberts
     * -----------------------------------------------------
     * This file contains the private section of the bst.h interface.
     * This portion of the class definition is taken out of the bst.h
     * header so that the client need not have to see all of these
     * details.
     */

    public:

    /*
     * Class: BST<ElemType>::Iterator
     * ------------------------------
     * This interface defines a nested class within the BST template that
     * provides iterator access to the keys contained in the BST.
     */

        class Iterator {
        public:
            Iterator();
            bool hasNext();
            ElemType next();

        private:
            struct iteratorMarkerT {
                void *np;
                bool processed;
            };

            Iterator(BST *bstp);
            BST *bstp;
            Stack<iteratorMarkerT> stack;
            long timestamp;
            void advanceToNextNode();
            void findLeftmostChild();
            friend class BST;
        };
        friend class Iterator;
        ElemType foreachHook(FE_State & _fe);

    /*
     * Deep copying support
     * --------------------
     * This copy constructor and operator= are defined to make a
     * deep copy, making it possible to pass/return trees by value
     * and assign from one tree to another. The entire contents of
     * the tree, including all elements, are copied. Each tree
     * element is copied from the original tree to the copy using
     * assignment (operator=). Making copies is generally avoided
     * because of the expense and thus, trees are typically passed
     * by reference, however, when a copy is needed, these operations
     * are supported.
     */
        const BST & operator=(const BST & rhs);
        BST(const BST & rhs);

    private:

    /* Type definition for node in the tree */
        struct nodeT {
            ElemType data;
            nodeT *left, *right;
            int bf;    /* AVL balance factor */
        };

    /* Constant definitions */
        static const int BST_RIGHT_HEAVY = +1;
        static const int BST_IN_BALANCE = 0;
        static const int BST_LEFT_HEAVY = -1;

    /* Instance variables */
        nodeT *root;
        int numNodes;
        long timestamp;
        int (*cmpFn)(ElemType, ElemType);

    /* Private method prototypes */
        nodeT *recFindNode(nodeT *t, ElemType & key);
        bool recAddNode(nodeT * & t, ElemType & key, bool & createdNewNode);
        bool recRemoveNode(nodeT * & t, ElemType & key, bool & didRemove);
        bool removeTargetNode(nodeT * & t);
        void updateBF(nodeT * & t, int bfDelta);
        void recDeleteTree(nodeT *t);
        void recBSTAll(nodeT *t, void (*fn)(ElemType));
        void fixRightImbalance(nodeT * & t);
        void fixLeftImbalance(nodeT * & t);
        void rotateRight(nodeT * & t);
        void rotateLeft(nodeT * & t);
        void copyOtherEntries(const BST & other);

    /* Template method prototypes */

        template <typename ClientDataType>
        void recBSTAll(nodeT *t, void (*fn)(ElemType, ClientDataType &),
                       ClientDataType & data);

};

//#include "private/bst.cpp"
/*
 * File: private/bst.cpp
 * Last modified on Thu Jun 11 09:17:43 2009 by eroberts
 * -----------------------------------------------------
 * This file contains the implementation of the bst.h interface.
 * Because of the way C++ compiles templates, this code must be
 * available to the compiler when it reads the header file.
 */

//#ifdef _bst_h

template <typename ElemType>
BST<ElemType>::BST(int (*cmp)(ElemType, ElemType)) {
    root = NULL;
    cmpFn = cmp;
    numNodes = 0;
    timestamp = 0L;
}

template <typename ElemType>
BST<ElemType>::~BST() {
    recDeleteTree(root);
}

template <typename ElemType>
void BST<ElemType>::recDeleteTree(nodeT * t) {
    if (t != NULL) {
        recDeleteTree(t->left);
        recDeleteTree(t->right);
        delete t;
    }
}

template <typename ElemType>
int BST<ElemType>::size() {
    return numNodes;
}

template <typename ElemType>
bool BST<ElemType>::isEmpty() {
    return root == NULL;
}

template <typename ElemType>
void BST<ElemType>::clear() {
    recDeleteTree(root);
    root = NULL;
    numNodes = 0;
    timestamp++;
}

/*
 * Implementation notes: find, recFindNode
 * ---------------------------------------
 * The find method simply calls recFindNode to do the work.
 * The recursive function takes the current node along with the
 * original argument.  If found, it overwrites the reference
 * parameter with the copy and returns a pointer to the data.
 */

template <typename ElemType>
ElemType *BST<ElemType>::find(ElemType key) {
    nodeT *found = recFindNode(root, key);
    if (found == NULL) return NULL;
    return &found->data;
}

template <typename ElemType>
typename BST<ElemType>::nodeT *BST<ElemType>::recFindNode(nodeT *t,
                                                      ElemType & key) {
    if (t == NULL) return NULL;
    int sign = cmpFn(key, t->data);
    if (sign == 0) return t;
    if (sign < 0) {
        return recFindNode(t->left, key);
    } else {
        return recFindNode(t->right, key);
    }
}

/*
 * Implementation notes: add, recAddNode
 * -------------------------------------
 * The add method is implemented as a simple wrapper
 * to recAddNode, which does all the work.  The difference
 * between the prototypes is that recAddNode takes a reference
 * to the root of the current subtree as an extra argument.
 * For reasons of efficiency (we don't know how large ElemType
 * might be), we pass it by reference.
 *
 * The return value from recAddNode is true or false, depending on
 * whether the height of the subtree was increased by one or not.
 * At base case, returns true for new node, false for overwite. As
 * it works its way upwards, if that additional height is added to
 * to existing balanace factor and results in factor that is
 * more than +- 1, then a rotation is done to fix the imbalance.
 */

template <typename ElemType>
bool BST<ElemType>::add(ElemType data) {
    bool createdNewNode = false;
    recAddNode(root, data, createdNewNode);
    if (createdNewNode) timestamp++;
    return createdNewNode;
}

template <typename ElemType>
bool BST<ElemType>::recAddNode(nodeT * & t, ElemType & data,
                               bool & createdNewNode) {
    if (t == NULL) {
        t = new nodeT;
        t->data = data;
        t->bf = BST_IN_BALANCE;
        t->left = t->right = NULL;
        createdNewNode = true;
        numNodes++;
        return true;
    }
    int sign = cmpFn(data, t->data);
    if (sign == 0) {
        t->data = data;
        createdNewNode = false;
        return false;
    }
    int bfDelta = 0;
    if (sign < 0) {
        if (recAddNode(t->left, data, createdNewNode)) {
            bfDelta = -1;   /* left subtree is higher */
        }
    } else {
        if (recAddNode(t->right, data, createdNewNode)) {
            bfDelta = +1;   /* right subtree is higher */
        }
    }
    updateBF(t, bfDelta);
    return (bfDelta != 0 && t->bf != BST_IN_BALANCE);
}

/*
 * Function: updateBF
 * Usage: updateBF(t, bfDelta);
 * ----------------------------
 * Updates the balance factor in the node and rebalances the
 * tree if necessary.
 */

template <typename ElemType>
void BST<ElemType>::updateBF(nodeT * & t, int bfDelta) {
    t->bf += bfDelta;
    if (t->bf < BST_LEFT_HEAVY) {
        fixLeftImbalance(t);
    } else if (t->bf > BST_RIGHT_HEAVY) {
        fixRightImbalance(t);
    }
}

/*
 * Function: fixLeftImbalance
 * Usage: fixLeftImbalance(t);
 * ---------------------------
 * This function is called when a node has been found that
 * is out of balance with the longer subtree on the left.
 * Depending on the balance factor of the left child, the
 * code performs a single or double rotation.
 */

template <typename ElemType>
void BST<ElemType>::fixLeftImbalance(nodeT * & t) {
    nodeT *child = t->left;
    if (child->bf == BST_RIGHT_HEAVY) {
        int oldBF = child->right->bf;
        rotateLeft(t->left);
        rotateRight(t);
        t->bf = BST_IN_BALANCE;
        switch (oldBF) {
          case BST_LEFT_HEAVY:
            t->left->bf = BST_IN_BALANCE;
            t->right->bf = BST_RIGHT_HEAVY;
            break;
          case BST_IN_BALANCE:
            t->left->bf = t->right->bf = BST_IN_BALANCE;
            break;
          case BST_RIGHT_HEAVY:
            t->left->bf = BST_LEFT_HEAVY;
            t->right->bf = BST_IN_BALANCE;
            break;
        }
    } else if (child->bf == BST_IN_BALANCE) {
        rotateRight(t);
        t->bf = BST_RIGHT_HEAVY;
        t->right->bf = BST_LEFT_HEAVY;
    } else {
        rotateRight(t);
        t->right->bf = t->bf = BST_IN_BALANCE;
    }
}

/*
 * Function: rotateLeft
 * Usage: rotateLeft(t);
 * ---------------------
 * This function performs a single left rotation of the tree
 * that is passed by reference.  The balance factors
 * are unchanged by this function and must be corrected at a
 * higher level of the algorithm.
 */

template <typename ElemType>
void BST<ElemType>::rotateLeft(nodeT * & t) {
    nodeT * child = t->right;
    t->right = child->left;
    child->left = t;
    t = child;
}

/*
 * Function: fixRightImbalance
 * Usage: fixRightImbalance(t);
 * ---------------------------
 * This function is called when a node has been found that
 * is out of balance with the longer subtree on the right.
 * Depending on the balance factor of the right child, the
 * code performs a single or double rotation.
 */

template <typename ElemType>
void BST<ElemType>::fixRightImbalance(nodeT * & t) {
    nodeT *child = t->right;
    if (child->bf == BST_LEFT_HEAVY) {
        int oldBF = child->left->bf;
        rotateRight(t->right);
        rotateLeft(t);
        t->bf = BST_IN_BALANCE;
        switch (oldBF) {
          case BST_LEFT_HEAVY:
            t->left->bf = BST_IN_BALANCE;
            t->right->bf = BST_RIGHT_HEAVY;
            break;
          case BST_IN_BALANCE:
            t->left->bf = t->right->bf = BST_IN_BALANCE;
            break;
          case BST_RIGHT_HEAVY:
            t->left->bf = BST_LEFT_HEAVY;
            t->right->bf = BST_IN_BALANCE;
            break;
        }
    } else if (child->bf == BST_IN_BALANCE) {
        rotateLeft(t);
        t->bf = BST_LEFT_HEAVY;
        t->left->bf = BST_RIGHT_HEAVY;
    } else {
        rotateLeft(t);
        t->left->bf = t->bf = BST_IN_BALANCE;
    }
}

/*
 * Function: rotateRight
 * Usage: rotateRight(t);
 * ----------------------
 * This function performs a single right rotation of the tree
 * that is passed by reference.  The balance factors
 * are unchanged by this function and must be corrected at a
 * higher level of the algorithm.
 */

template <typename ElemType>
void BST<ElemType>::rotateRight(nodeT * & t) {
    nodeT * child = t->left;
    t->left = child->right;
    child->right = t;
    t = child;
}

/*
 * Implementation notes: remove
 * ----------------------------
 * The first step in removing a node is to find it using binary
 * search, which is performed by the recRemoveNode method.  If the
 * node is found, RemoveTargetNode does the actual deletion.
 */

template <typename ElemType>
bool BST<ElemType>::remove(ElemType data) {
    bool didRemove = false;
    recRemoveNode(root, data, didRemove);
    if (didRemove) timestamp++;
    return didRemove;
}

/*
 * Implementation notes: recRemoveNode
 * -----------------------------------
 * This method implements the general case for removing a node.
 * In addition to taking the root of the tree as a parameter, this
 * method takes a flag called didRemove, which is set if a matching
 * was found in the search.  The function returns the change in the
 * size of the tree rooted at t.
 */

template <typename ElemType>
bool BST<ElemType>::recRemoveNode(nodeT * & t, ElemType & data,
                                  bool & didRemove) {
    if (t == NULL) return false;
    int sign = cmpFn(data, t->data);
    if (sign == 0) {
        didRemove = true;
        return removeTargetNode(t);
    }
    int bfDelta = 0;
    if (sign < 0) {
        if (recRemoveNode(t->left, data, didRemove)) bfDelta = +1;
    } else {
        if (recRemoveNode(t->right, data, didRemove)) bfDelta = -1;
    }
    updateBF(t, bfDelta);
    return (bfDelta != 0 && t->bf == BST_IN_BALANCE);
}

/*
 * Implementation notes: removeTargetNode
 * --------------------------------------
 * This function removes the node which is passed by
 * reference as t.  The easy case occurs when either of the
 * children is NULL; all you need to do is replace the node with
 * its non-NULL child.  If both children are non-NULL, this code
 * finds the rightmost descendent of the left child; this node
 * may not be a leaf, but will have no right child.  Its left
 * child replaces it in the tree, after which the replacement
 * data is moved to the position occupied by the target node.
 */

template <typename ElemType>
bool BST<ElemType>::removeTargetNode(nodeT *  & t) {
    nodeT *toDelete = t;
    if (t->left == NULL) {          /* No left child, replace with right */
        t = t->right;
        delete toDelete;
        numNodes--;
        return true;
    } else if (t->right == NULL) {  /* No right child, replace with left */
        t = t->left;
        delete toDelete;
        numNodes--;
        return true;
    } else {  /* node has both children, replace with max of left */
        nodeT *successor = t->left;
        while (successor->right != NULL) {
            successor = successor->right;
        }
        t->data = successor->data;
        bool unused;
        if (recRemoveNode(t->left, successor->data, unused)) {
            updateBF(t, 1);
            return (t->bf == BST_IN_BALANCE);
        }
        return false;
    }
}

/*
 * Implementation notes: mapAll, recBSTAll
 * ----------------------------------------
 * The mapAll function is implemented as a wrapper to the
 * recursive function recBSTAll, which does the actual work
 * of calling the function on all values during an InOrder walk.
 */
template <typename ElemType>
void BST<ElemType>::mapAll(void (*fn)(ElemType)) {
    recBSTAll(root, fn);
}

template <typename ElemType>
void BST<ElemType>::recBSTAll(nodeT * t, void (*fn)(ElemType)) {
    if (t != NULL) {
        recBSTAll(t->left, fn);
        fn(t->data);
        recBSTAll(t->right, fn);
    }
}

template <typename ElemType>
template <typename ClientDataType>
    void BST<ElemType>::mapAll(void (*fn)(ElemType, ClientDataType &),
                               ClientDataType & data) {
        recBSTAll(root, fn, data);
    }

template <typename ElemType>
template <typename ClientDataType>
void BST<ElemType>::recBSTAll(nodeT *t, void (*fn)(ElemType, ClientDataType &),
                              ClientDataType & data) {
    if (t != NULL) {
        recBSTAll(t->left, fn ,data);
        fn(t->data, data);
        recBSTAll(t->right, fn, data);
    }
}

template <typename ElemType>
const BST<ElemType> &BST<ElemType>::operator=(const BST & rhs) {
    if (this != &rhs) {
        clear();
        copyOtherEntries(rhs);
        timestamp = 0L;
    }
    return *this;
}

template <typename ElemType>
BST<ElemType>::BST(const BST & rhs) {
    root = NULL;
    copyOtherEntries(rhs);
    timestamp = 0L;
}

template <typename ElemType>
static void AddToTree(ElemType elem, BST<ElemType> & tree) {
    tree.add(elem);
}

/*
 * Private method: copyOtherEntries
 * Usage: copyOtherEntries(otherBST);
 * ----------------------------------
 * This methods adds a copy of all entries from the other map to
 * this one.
 *
 * Implementation note: We aren't really adhering to const. Even though
 * the methods invoked on rhs don't modify it, they aren't marked const,
 * and thus trigger compiler problems. We cast away const-ness to avoid
 * this erroneous complaints. Sigh.
 *
 * The implementation also maps over the cells to copy as a workaround
 * for a bug in Metrowerks C++ compiler, which can't handle the
 * dual-templated map function correctly.
 */

template <typename ElemType>
void BST<ElemType>::copyOtherEntries(const BST & constRhs) {
    BST & rhs = const_cast<BST &>(constRhs);
    cmpFn = rhs.cmpFn;
    rhs.mapAll< BST<ElemType> >(AddToTree, *this);
    numNodes = rhs.numNodes;
}

/*
 * BST::Iterator class implementation
 */

template <typename ElemType>
BST<ElemType>::Iterator::Iterator() {
    bstp = NULL;
}

template <typename ElemType>
typename BST<ElemType>::Iterator BST<ElemType>::iterator() {
    return Iterator(this);
}

template <typename ElemType>
BST<ElemType>::Iterator::Iterator(BST *bstptr) {
    bstp = bstptr;
    timestamp = bstp->timestamp;
    if (bstp->root == NULL) return;
    iteratorMarkerT marker = { (void *) bstp->root, false };
    stack.push(marker);
    findLeftmostChild();
}

template <typename ElemType>
bool BST<ElemType>::Iterator::hasNext() {
    if (bstp == NULL) Error("hasNext called on uninitialized iterator");
    if (timestamp != bstp->timestamp) {
        Error("BST structure has been modified");
    }
    return !stack.isEmpty();
}

template <typename ElemType>
ElemType BST<ElemType>::Iterator::next() {
    if (bstp == NULL) Error("next called on uninitialized iterator");
    if (!hasNext()) {
        Error("Attempt to get next from iterator"
              " where hasNext() is false");
    }
    nodeT *np = (nodeT *) stack.peek().np;
    ElemType result = np->data;
    advanceToNextNode();
    return result;
}

template <typename ElemType>
void BST<ElemType>::Iterator::advanceToNextNode() {
    iteratorMarkerT marker = stack.pop();
    nodeT *np = (nodeT *) marker.np;
    if (np->right == NULL) {
        while (!stack.isEmpty() && stack.peek().processed) {
            stack.pop();
        }
    } else {
        marker.processed = true;
        stack.push(marker);
        marker.np = (void *) np->right;
        marker.processed = false;
        stack.push(marker);
        findLeftmostChild();
    }
}

template <typename ElemType>
void BST<ElemType>::Iterator::findLeftmostChild() {
    nodeT *np = (nodeT *) stack.peek().np;
    if (np == NULL) return;
    while (np->left != NULL) {
        iteratorMarkerT marker = { (void *) np->left,  false };
        stack.push(marker);
        np = np->left;
    }
}

template <typename ElemType>
ElemType BST<ElemType>::foreachHook(FE_State & fe) {
    if (fe.state == 0) fe.iter = new Iterator(this);
    if (((Iterator *) fe.iter)->hasNext()) {
        fe.state = 1;
        return ((Iterator *) fe.iter)->next();
    } else {
        fe.state = 2;
        return ElemType();
    }
}

//#endif

//#endif

/*
 * Class: Set
 * ----------
 * This interface defines a class template that stores a collection of
 * distinct elements, using a sorted relation on the elements to
 * provide efficient managaement of the collection.
 * For maximum generality, the Set is supplied as a class template.
 * The element type is determined by the client. The client configures
 * the set to hold values of a specific type, e.g. Set<int> or
 * Set<studentT>. The one requirement on the element type is that the
 * client must supply a comparison function that compares two elements
 * (or be willing to use the default comparison function that uses
 * the built-on operators  < and ==).
 */

template <typename ElemType>
class Set {

public:

/* Forward references */
    class Iterator;

/*
 * Constructor: Set
 * Usage: Set<int> set;
 *        Set<student> students(CompareStudentsById);
 *        Set<string> *sp = new Set<string>;
 * -----------------------------------------
 * The constructor initializes an empty set. The optional
 * argument is a function pointer that is applied to
 * two elements to determine their relative ordering. The
 * comparison function should return 0 if the two elements
 * are equal, a negative result if first is "less than" second,
 * and a positive resut if first is "greater than" second. If
 * no argument is supplied, the OperatorCmp template is used as
 * a default, which applies the bulit-in < and == to the
 * elements to determine ordering.
 */
    Set(int (*cmpFn)(ElemType, ElemType) = OperatorCmp);

/*
 * Destructor: ~Set
 * Usage: delete sp;
 * -----------------
 * The destructor deallocates  storage associated with set.
 */
    ~Set();

/*
 * Method: size
 * Usage: count = set.size();
 * --------------------------
 * This method returns the number of elements in this set.
 */
    int size();

/*
 * Method: isEmpty
 * Usage: if (set.isEmpty())...
 * ----------------------------
 * This method returns true if this set contains no
 * elements, false otherwise.
 */
    bool isEmpty();

/*
 * Method: add
 * Usage: set.add(value);
 * ----------------------
 * This method adds an element to this set. If the
 * value was already contained in the set, the existing entry is
 * overwritten by the new copy, and the set's size is unchanged.
 * Otherwise, the value is added and set's size increases by one.
 */
    void add(ElemType elem);

/*
 * Method: remove
 * Usage: set.remove(value);
 * -----------------------
 * This method removes an element from this set. If the
 * element was not contained in the set, the set is unchanged.
 * Otherwise, the element is removed and the set's size decreases
 * by one.
 */
    void remove(ElemType elem);

/*
 * Method: contains
 * Usage: if (set.contains(value))...
 * -----------------------------------
 * Returns true if the element in this set, false otherwise.
 */
    bool contains(ElemType elem);

/*
 * Method: find
 * Usage: eptr = set.find(elem);
 * -----------------------------
 * If the element is contained in this set, returns a pointer
 * to that elem.  The pointer allows you to update that element
 * in place. If element is not contained in this set, NULL is
 * returned.
 */
    ElemType *find(ElemType elem);

/*
 * Method: equals
 * Usage: if (set.equals(set2)) . . .
 * -----------------------------------
 * This predicate function implements the equality relation
 * on sets.  It returns true if this set and set2 contain
 * exactly the same elements, false otherwise.
 */
    bool equals(Set & otherSet);

/*
 * Method: isSubsetOf
 * Usage: if (set.isSubsetOf(set2)) . . .
 * --------------------------------------
 * This predicate function implements the subset relation
 * on sets.  It returns true if all of the elements in this
 * set are contained in set2.  The set2 does not have to
 * be a proper subset (that is, it may be equals).
 */
    bool isSubsetOf(Set & otherSet);

/*
 * Methods: unionWith, intersectWith, subtract
 * Usage: set.unionWith(set2);
 *        set.intersectWith(set2);
 *        set.subtract(set2);
 * -------------------------------
 * These fmember unctions modify the receiver set as follows:
 *
 * set.unionWith(set2);      Adds all elements from set2 to this set.
 * set.intersectWith(set2);  Removes any element not in set2 from this set.
 * set.subtract(set2);       Removes all element in set2 from this set.
 */
    void unionWith(Set & otherSet);
    void intersectWith(Set & otherSet);
    void subtract(Set & otherSet);

/*
 * Method: clear
 * Usage: set.clear();
 * -------------------
 * This method removes all elements from this set. The
 * set is made empty and will have size() = 0 after being cleared.
 */
    void clear();

/*
 * SPECIAL NOTE: mapping/iteration support
 * ---------------------------------------
 * The set supports both a mapping operation and an iterator which
 * allow the client access to all elements one by one.  In general,
 * these  are intended for _viewing_ elements and can behave
 * unpredictably if you attempt to modify the set's contents during
 * mapping/iteration.
 */

/*
 * Method: mapAll
 * Usage: set.mapAll(Print);
 * -------------------------
 * This method iterates through this set's contents
 * and calls the function fn once for each element.
 */
    void mapAll(void (*fn)(ElemType elem));

/*
 * Method: mapAll
 * Usage: set.mapAll(PrintToFile, outputStream);
 * --------------------------------------------
 * This method iterates through this set's contents
 * and calls the function fn once for each element, passing
 * the element and the client's data. That data can be of whatever
 * type is needed for the client's callback.
 */
    template <typename ClientDataType>
    void mapAll(void (*fn)(ElemType elem, ClientDataType & data),
                ClientDataType & data);

/*
 * Method: iterator
 * Usage: iter = set.iterator();
 * -----------------------------
 * This method creates an iterator that allows the client to
 * iterate through the elements in this set.  The elements are
 * returned in the order determined by the comparison function.
 *
 * The idiomatic code for accessing elements using an iterator is
 * to create the iterator from the collection and then enter a loop
 * that calls next() while hasNext() is true, like this:
 *
 *     Set<int>::Iterator iter = set.iterator();
 *     while (iter.hasNext()) {
 *         int value = iter.next();
 *         . . .
 *     }
 *
 * This pattern can be abbreviated to the following more readable form:
 *
 *     foreach (int value in set) {
 *         . . .
 *     }
 *
 * To avoid exposing the details of the class, the definition of the
 * Iterator class itself appears in the private/set.h file.
 */
    Iterator iterator();

private:

//#include "private/set.h"
    /*
     * File: private/set.h
     * Last modified on Fri Jun  5 15:39:43 2009 by eroberts
     * -----------------------------------------------------
     * This file contains the private section of the set.h interface.
     * This portion of the class definition is taken out of the set.h
     * header so that the client need not have to see all of these
     * details.
     */

    public:

    /*
     * Legacy function: intersect
     * --------------------------
     * This name was changed to intersectWith for symmetry with unionWith.
     */
        void intersect(Set & otherSet);

    /*
     * Class: Set<ElemType>::Iterator
     * ---------------------------------
     * This interface defines a nested class within the Set template that
     * provides iterator access to the Set contents.
     */
        class Iterator : public FE_Iterator {
        public:
            Iterator();
            bool hasNext();
            ElemType next();

        private:
            Iterator(Set *setptr);
            typename BST<ElemType>::Iterator iterator;
            friend class Set;
        };
        friend class Iterator;
        ElemType foreachHook(FE_State & _fe);

    /*
     * Deep copying support
     * --------------------
     * Because all Set data members have correct behavior on operator=
     * and copy constructor, the default for these as synthesized by
     * the compiler make a correct copy of the Set. When pass/return
     * sets by value, or assign one to another, the entire contents of
     * the set, including all elements, are copied. Each set
     * element is copied from the original set to the copy using
     * assignment (operator=). Making copies is generally avoided
     * because of the expense and thus, sets are typically passed by
     * reference, however, when a copy is needed, these operations
     * are supported.
     */

    private:
        BST<ElemType> bst;
        int (*cmpFn)(ElemType, ElemType);

};

//#include "private/set.cpp"
/*
 * File: private/set.cpp
 * Last modified on Thu Jun 11 09:34:08 2009 by eroberts
 * -----------------------------------------------------
 * This file contains the implementation of the set.h interface.
 * Because of the way C++ compiles templates, this code must be
 * available to the compiler when it reads the header file.
 */

//#ifdef _set_h

template <typename ElemType>
Set<ElemType>::Set(int (*cmp)(ElemType, ElemType)) : bst(cmp) {
    cmpFn = cmp;
}

template <typename ElemType>
Set<ElemType>::~Set() {
    /* Empty */
}

template <typename ElemType>
int Set<ElemType>::size() {
    return bst.size();
}

template <typename ElemType>
bool Set<ElemType>::isEmpty() {
    return bst.isEmpty();
}

template <typename ElemType>
void Set<ElemType>::add(ElemType element) {
    bst.add(element);
}

template <typename ElemType>
void Set<ElemType>::remove(ElemType element) {
    bst.remove(element);
}

template <typename ElemType>
bool Set<ElemType>::contains(ElemType element) {
    return find(element) != NULL;
}

template <typename ElemType>
ElemType *Set<ElemType>::find(ElemType element) {
    return bst.find(element);
}

template <typename ElemType>
void Set<ElemType>::clear() {
    bst.clear();
}

/*
 * Implementation notes: Set operations
 * ------------------------------------
 * The code for equals, isSubsetOf, unionWith, intersectWith, and subtract
 * is similar in structure.  Each one uses an iterator to walk over
 * one (or both) sets, doing add/remove/comparision.
 */

template <typename ElemType>
bool Set<ElemType>::equals(Set & otherSet) {
    if (cmpFn != otherSet.cmpFn) {
        Error("Equals: sets have different comparison functions");
    }
    Iterator thisItr = iterator(), otherItr = otherSet.iterator();
    while (thisItr.hasNext() && otherItr.hasNext()) {
        if (cmpFn(thisItr.next(), otherItr.next()) != 0) return false;
    }
    return !thisItr.hasNext() && !otherItr.hasNext();
}

template <typename ElemType>
bool Set<ElemType>::isSubsetOf(Set & otherSet) {
    if (cmpFn != otherSet.cmpFn) {
        Error("isSubsetOf: sets have different comparison functions");
    }
    Iterator iter = iterator();
    while (iter.hasNext()) {
        if (!otherSet.contains(iter.next())) return false;
    }
    return true;
}

template <typename ElemType>
void Set<ElemType>::unionWith(Set & otherSet) {
    if (cmpFn != otherSet.cmpFn) {
        Error("unionWith: sets have different comparison functions");
    }
    Iterator iter = otherSet.iterator();
    while (iter.hasNext()) {
        add(iter.next());
    }
}

/*
 * Implementation notes: intersectWith
 * -----------------------------------
 * The most obvious way to write this method (iterating over
 * one set and deleting members that are not in the second)
 * fails because you can't change the contents of a collection
 * over which you're iterating.  This code puts the elements
 * to be deleted in a vector and then deletes those.
 */

template <typename ElemType>
void Set<ElemType>::intersectWith(Set & otherSet) {
    if (cmpFn != otherSet.cmpFn) {
        Error("intersectWith:"
              " sets have different comparison functions");
    }
    Iterator iter = iterator();
    Vector<ElemType> toDelete;
    while (iter.hasNext()) {
        ElemType elem = iter.next();
        if (!otherSet.contains(elem)) toDelete.add(elem);
    }
    for (int i = 0; i < toDelete.size(); i++) {
        remove(toDelete[i]);
    }
}

template <typename ElemType>
void Set<ElemType>::intersect(Set & otherSet) {
    if (cmpFn != otherSet.cmpFn) {
        Error("intersect: sets have different comparison functions");
    }
    intersectWith(otherSet);
}

template <typename ElemType>
void Set<ElemType>::subtract(Set & otherSet) {
    if (cmpFn != otherSet.cmpFn) {
        Error("subtract: sets have different comparison functions");
    }
    Iterator iter = otherSet.iterator();
    while (iter.hasNext()) {
        remove(iter.next());
    }
}

template <typename ElemType>
void Set<ElemType>::mapAll(void (*fn)(ElemType)) {
    bst.mapAll(fn);
}

template <typename ElemType>
template <typename ClientDataType>
void Set<ElemType>::mapAll(void (*fn)(ElemType, ClientDataType &),
                           ClientDataType & data) {
    bst.mapAll(fn, data);
}

/*
 * Set::Iterator class implementation
 * ----------------------------------
 * The Iterator for Set relies on the underlying implementation of the
 * Iterator for the BST class.
 */

template <typename ElemType>
Set<ElemType>::Iterator::Iterator() {
    /* Empty */
}

template <typename ElemType>
typename Set<ElemType>::Iterator Set<ElemType>::iterator() {
    return Iterator(this);
}

template <typename ElemType>
Set<ElemType>::Iterator::Iterator(Set *setptr) {
    iterator = setptr->bst.iterator();
}

template <typename ElemType>
bool Set<ElemType>::Iterator::hasNext() {
    return iterator.hasNext();
}

template <typename ElemType>
ElemType Set<ElemType>::Iterator::next() {
    return iterator.next();
}

template <typename ElemType>
ElemType Set<ElemType>::foreachHook(FE_State & fe) {
    if (fe.state == 0) fe.iter = new Iterator(this);
    if (((Iterator *) fe.iter)->hasNext()) {
        fe.state = 1;
        return ((Iterator *) fe.iter)->next();
    } else {
        fe.state = 2;
        return ElemType();
    }
}

//#endif

//#endif
/*********************************MAZE********************************************************/
/*
 * File: maze.h
 * ------------
 * Defines the Maze class.
 * Last modified Tue Jan 22 20:19:35 PST 2008 jzelenski
 */

//#ifndef _maze_h
//#define _maze_h

//#include "genlib.h"
//#include "grid.h"
#include <cstdlib>

/*
 * Class: Maze
 * -----------
 * This class is used to represent a maze and provide operations to
 * query and change the maze configuration. A maze is a rectangular grid
 * of cells. Each cell identified by pointT (row-col struct).
 * Coordinates in the maze are numbered starting at (0,0) in
 * the lower left corner.
 * A location has neighbors in the four major compass directions (some
 * neighbors may not exist for cells along the outer border).  The
 * maze tracks which walls are up bewteen a cell and its neighbor.
 */


/*
 * Type: pointT
 * ------------
 * The type pointT is used to encapsulate a pair of integer
 * coordinates into a single value with row and col components.
 */

struct pointT {
    int row;
    int col;
};


class Maze {
    public:
    
        /*
         * Constructor: Maze
         * Usage: Maze m(10, 20, true);
         * ----------------------------
         * The constructor initializes a new maze of the specified dimensions.
         * If the hasWalls argument is true, the maze is initially configured with
         * all walls intact. If false, the maze starts with no walls at all.
         */
        Maze(int numRows, int numCols, bool hasWalls);
        
        /*
         * Member functions: numRows, numCols
         * Usage: nRows = maze.numRows();
         * ------------------------------
         * These member functions return the number of rows or columns in
         * this maze.
         */
        int numRows();
        int numCols();
        
        /*
         * Member functions: pointInBounds
         * Usage: if (!maze.pointInBounds(pt))
         * -----------------------------------
         * This member function returns true if p is within bounds of this
         * maze, false otherwise.
         */
        bool pointInBounds(pointT p);

         /*
         * Member function: isWall
         * Usage: if (maze.isWall(a, b))...
         * ---------------------------------
         * This member function returns true if there is a wall between
         * the two cells at points p1 and p2. If the two points are
         * not neighbors or if either is out of bounds, an error is raised.
         */
        bool isWall(pointT p1, pointT p2);
        
         /*
         * Member function: setWall
         * Usage: maze.setWall(a, b, true);
         * --------------------------------
         * This member function sets the wall between cells at points
         * p1 and p2 to state. It can be used to either add or remove
         * walls. The graphical display is updated to match. If the two
         * points are not neighbors or either point is out of bounds,
         * an error is raised.
         */
        void setWall(pointT p1, pointT p2, bool state);
        
        
        /*
         * Member function: draw
         * Usage: maze.draw();
         * -------------------
         * This member function draws the maze configuration to the graphics
         * window, erasing any previous contents. The lower-left corner is
         * the cell identified by 0-0. The maze itself is white and walls are
         * drawn with black lines. All previous marks are cleared.
         */
        void draw();


        /*
         * Member function: drawMark
         * Usage: maze.drawMark(p, "Red");
         * ------------------------------
         * This member function draws a mark on the cell at point p
         * in the specified color. To erase a previous mark, you
         * can redraw one in white or use the draw function to reset
         * all marks.
         */
        void drawMark(pointT p, string color);
    
        
        private:
            enum dirT {North, East, South, West, NumDirs};
            struct cellT {bool walls[NumDirs];};
            Grid<cellT> cells;
            double originX, originY, cellSize;
            bool configured;
        
            dirT neighborDir(pointT p1, pointT p2);
            void drawWallsForCell(pointT p);
            void configureGraphics();
};

//#endif
/*
 * File: maze.cpp
 * --------------
 * A maze is mostly a grid of walls. plus a little drawing code.
 */

//#include "maze.h"
//#include "extgraph.h"
/*
 * File: extgraph.h
 * Last modified on Wed Apr  1 07:48:21 2009 by eroberts
 *      modified on Wed Sep 18 14:38:14 2002 by zelenski
 * -----------------------------------------------------
 * This interface is the extended graphics interface.
 * It includes all of the facilities in graphics.h, plus
 * several additional functions that are designed to
 * support more sophisticated, interactive graphics.
 */

//#ifndef _extgraph_h
//#define _extgraph_h

//#include "genlib.h"

/* Exported functions */

/* Section 1 -- Basic functions from graphics.h */

//#include "graphics.h"
/*
 * File: graphics.h
 * Last modified on Wed Apr  1 07:49:39 2009 by eroberts
 *      modified on Wed Sep 18 14:37:43 2002 by zelenski
 * -----------------------------------------------------
 * This interface provides access to a simple library of
 * functions that make it possible to draw lines and arcs
 * on the screen.  This interface presents a portable
 * abstraction that can be used with a variety of window
 * systems implemented on different hardware platforms.
 */

//#ifndef _graphics_h
//#define _graphics_h

/*
 * Overview
 * --------
 * This library provides several functions for drawing lines
 * and circular arcs in a region of the screen that is
 * defined as the "graphics window."  Once drawn, these
 * lines and arcs stay in their position, which means that
 * the package can only be used for static pictures and not
 * for animation.
 *
 * Individual points within the window are specified by
 * giving their x and y coordinates.  These coordinates are
 * real numbers measured in inches, with the origin in the
 * lower left corner, as it is in traditional mathematics.
 *
 * The calls available in the package are listed below.  More
 * complete descriptions are included with each function
 * description.
 *
 *   InitGraphics();
 *   MovePen(x, y);
 *   DrawLine(dx, dy);
 *   DrawArc(r, start, sweep);
 *   width = GetWindowWidth();
 *   height = GetWindowHeight();
 *   x = GetCurrentX();
 *   y = GetCurrentY();
 */

/*
 * Function: InitGraphics
 * Usage: InitGraphics();
 * ----------------------
 * This procedure creates the graphics window on the screen.
 * The call to InitGraphics must precede any calls to other
 * functions in this package and must also precede any printf
 * output.  In most cases, the InitGraphics call is the first
 * statement in the function main.
 */

void InitGraphics();

/*
 * Function: MovePen
 * Usage: MovePen(x, y);
 * ---------------------
 * This procedure moves the current point to the position
 * (x, y), without drawing a line.  The model is that of
 * the pen being lifted off the graphics window surface and
 * then moved to its new position.
 */

void MovePen(double x, double y);

/*
 * Function: DrawLine
 * Usage: DrawLine(dx, dy);
 * ------------------------
 * This procedure draws a line extending from the current
 * point by moving the pen dx inches in the x direction
 * and dy inches in the y direction.  The final position
 * becomes the new current point.
 */

void DrawLine(double dx, double dy);

/*
 * Function: DrawArc
 * Usage: DrawArc(r, start, sweep);
 * --------------------------------
 * This procedure draws a circular arc, which always begins
 * at the current point.  The arc itself has radius r, and
 * starts at the angle specified by the parameter start,
 * relative to the center of the circle.  This angle is
 * measured in degrees counterclockwise from the 3 o'clock
 * position along the x-axis, as in traditional mathematics.
 * For example, if start is 0, the arc begins at the 3 o'clock
 * position; if start is 90, the arc begins at the 12 o'clock
 * position; and so on.  The fraction of the circle drawn is
 * specified by the parameter sweep, which is also measured in
 * degrees.  If sweep is 360, DrawArc draws a complete circle;
 * if sweep is 90, it draws a quarter of a circle.  If the value
 * of sweep is positive, the arc is drawn counterclockwise from
 * the current point.  If sweep is negative, the arc is drawn
 * clockwise from the current point.  The current point at the
 * end of the DrawArc operation is the final position of the pen
 * along the arc.
 *
 * Examples:
 *   DrawArc(r, 0, 360)    Draws a circle to the left of the
 *                         current point.
 *   DrawArc(r, 90, 180)   Draws the left half of a semicircle
 *                         starting from the 12 o'clock position.
 *   DrawArc(r, 0, 90)     Draws a quarter circle from the 3
 *                         o'clock to the 12 o'clock position.
 *   DrawArc(r, 0, -90)    Draws a quarter circle from the 3
 *                         o'clock to the 6 o'clock position.
 *   DrawArc(r, -90, -90)  Draws a quarter circle from the 6
 *                         o'clock to the 9 o'clock position.
 */

void DrawArc(double r, double start, double sweep);

/*
 * Functions: GetWindowWidth, GetWindowHeight
 * Usage: width = GetWindowWidth();
 *        height = GetWindowHeight();
 * ------------------------------------------
 * These functions return the width and height of the graphics
 * window, in inches.
 */

double GetWindowWidth();
double GetWindowHeight();

/*
 * Functions: GetCurrentX, GetCurrentY
 * Usage: x = GetCurrentX();
 *        y = GetCurrentY();
 * -----------------------------------
 * These functions return the current x and y positions.
 */

double GetCurrentX();
double GetCurrentY();

//#endif
/*
 * File : graphics.cpp
 * Last modified September 2011 by Colin
 * -----------------------------------------
 * Implements the (few) functions in graphics.h
 * Responsible for establishing a Tcp connection with the server,
 * needed before any of the other graphics or extgraph functions will work
 */


//#include "graphics.h"
//#include "private/graphics.h"
/* File : private/graphics.h
 * Last modified September 2011 by Colin
 * -------------------------------------
 * adds a few extensions to the Stanford graphics.h,
 * needed by the open-source client/server implementation
 */

//#ifndef _PRIVGRAPHICS_H
//#define _PRIVGRAPHICS_H

#include <iostream>
#include <string>
#include <sstream>
//#include "../graphicsclient.h"
//#ifndef GRAPHICSCLIENT_H
//#define GRAPHICSCLIENT_H

#include <string>
#include <iostream>
//#include "ClientSocket.h"
// Definition of the ClientSocket class

//#ifndef ClientSocket_class
//#define ClientSocket_class

//#include "Socket.h"
/* Definition of the Socket class
   Closely based on tutorial code by Rob Tougher
   http://linuxgazette.net/74/tougher.html

   Last modified by Colin Leach, July 2011
*/

//#ifndef Socket_class
//#define Socket_class


#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <unistd.h>
#include <string>
#include <arpa/inet.h>


const int MAXHOSTNAME = 200;  // is this used anywhere?
const int MAXCONNECTIONS = 5;
const int MAXRECV = 500;

class Socket
{
 public:
  Socket();
  virtual ~Socket();

  // Server initialization
  bool create();
  bool bind ( const int port );
  bool listen() const;
  bool accept ( Socket& ) const;

  // Client initialization
  bool connect ( const std::string host, const int port );

  // Data Transimission
  bool send ( const std::string ) const;
  int recv ( std::string& ) const;


  void set_non_blocking ( const bool );

  bool is_valid() const { return m_sock != -1; }

 private:

  int m_sock;
  sockaddr_in m_addr;
};

/* Implementation of the Socket class.
   Closely based on tutorial code by Rob Tougher
   http://linuxgazette.net/74/tougher.html

   Last modified by Colin Leach, July 2011
*/

//#include "Socket.h"
//#include "string.h"
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <iostream>


Socket::Socket() :
  m_sock ( -1 )
{
  memset ( &m_addr,
       0,
       sizeof ( m_addr ) );
}

Socket::~Socket()
{
  if ( is_valid() )
    ::close ( m_sock );
}

bool Socket::create()
// To consider - would AF_UNIX/AF_LOCAL sometimes be better?
{
  m_sock = socket ( AF_INET,
            SOCK_STREAM,
            0 );

  if ( ! is_valid() )
    return false;

  // TIME_WAIT - argh
  int on = 1;
  if ( setsockopt ( m_sock, SOL_SOCKET, SO_REUSEADDR, ( const char* ) &on, sizeof ( on ) ) == -1 )
    return false;

  return true;
}


bool Socket::bind ( const int port )
{
  if ( ! is_valid() )
    {
      return false;
    }

  m_addr.sin_family = AF_INET;
  m_addr.sin_addr.s_addr = INADDR_ANY;
  m_addr.sin_port = htons ( port );

  int bind_return = ::bind ( m_sock,
                 ( struct sockaddr * ) &m_addr,
                 sizeof ( m_addr ) );

  if ( bind_return == -1 )
    {
      return false;
    }

  return true;
}


bool Socket::listen() const
{
  if ( ! is_valid() )
    {
      return false;
    }

  int listen_return = ::listen ( m_sock, MAXCONNECTIONS );


  if ( listen_return == -1 )
    {
      return false;
    }

  return true;
}


bool Socket::accept ( Socket& new_socket ) const
{
  int addr_length = sizeof ( m_addr );
  new_socket.m_sock = ::accept ( m_sock, ( sockaddr * ) &m_addr, ( socklen_t * ) &addr_length );

  if ( new_socket.m_sock <= 0 )
    return false;
  else
    return true;
}


bool Socket::send ( const std::string s ) const
{
  int status = ::send ( m_sock, s.c_str(), s.size(), MSG_NOSIGNAL );
  if ( status == -1 )
    {
      return false;
    }
  else
    {
      return true;
    }
}


int Socket::recv ( std::string& s ) const
{
  char buf [ MAXRECV + 1 ];

  s = "";

  memset ( buf, 0, MAXRECV + 1 );

  int status = ::recv ( m_sock, buf, MAXRECV, 0 );

  if ( status == -1 )
    {
      std::cout << "status == -1   errno == " << errno << "  in Socket::recv\n";
      return 0;
    }
  else if ( status == 0 )
    {
      return 0;
    }
  else
    {
      s = buf;
      return status;
    }
}



bool Socket::connect ( const std::string host, const int port )
{
  if ( ! is_valid() ) return false;

  m_addr.sin_family = AF_INET;
  m_addr.sin_port = htons ( port );

  int status = inet_pton ( AF_INET, host.c_str(), &m_addr.sin_addr );

  if ( errno == EAFNOSUPPORT ) return false;

  status = ::connect ( m_sock, ( sockaddr * ) &m_addr, sizeof ( m_addr ) );

  if ( status == 0 )
    return true;
  else
    return false;
}

void Socket::set_non_blocking ( const bool b )
{
  int opts;

  opts = fcntl ( m_sock,
         F_GETFL );

  if ( opts < 0 )
    {
      return;
    }

  if ( b )
    opts = ( opts | O_NONBLOCK );
  else
    opts = ( opts & ~O_NONBLOCK );

  fcntl ( m_sock,
      F_SETFL,opts );

}

//#endif


class ClientSocket : private Socket
{
 public:

  ClientSocket ( std::string host, int port );
  virtual ~ClientSocket(){};

  const ClientSocket& operator << ( const std::string& ) const;
  const ClientSocket& operator >> ( std::string& ) const;

};


//#endif

//#include "SocketException.h"
// SocketException class


//#ifndef SocketException_class
//#define SocketException_class

#include <string>

class SocketException
{
 public:
  SocketException ( std::string s ) : m_s ( s ) {};
  ~SocketException (){};

  std::string description() { return m_s; }

 private:

  std::string m_s;

};

//#endif

using namespace std;

class GraphicsClient
{
public:
    GraphicsClient(string host, int port);
    string ExchangeMsg(string cmd);

private:
    int InitClient(string host, int port);

    ClientSocket *_sock;
};


//#endif // GRAPHICSCLIENT_H


using namespace std;

void StartServer();
void SetPort(int port);

/* Some ugly global variables follow (sorry!)
 * These are things that need to be stored BEFORE creating the GraphicsClient object.
 * It's hard to see how else to handle them in a client/server context
 * without breaking the Stanford API.
 */
GraphicsClient *TcpClient = NULL;
int TcpPort = 30004;  // a fairly random number, that nobody else seems to be using
string CoordSystem = "inch";

//#endif // _PRIVGRAPHICS_H

//#include "simpio.h"
//#include "strutils.h"
//#include "genlib.h"
//#include "graphicsclient.h"

void SetPort(int port)
/* Sets a global variable, defined in private/graphics.h,
 * in case the student wants to override the default (30004).
 * Call this BEFORE calling InitGraphics() for the first time.
 */
{
    TcpPort = port;
}

void InitGraphics()
{
    if (TcpClient == NULL) {
    // Make initial connection
    try {
        cout<<"in InitGraphics"<<endl;
        TcpClient = new GraphicsClient("localhost", TcpPort);
        cout<<"TCP Client created"<<endl;
    }
    catch (ErrorException e) {
        StartServer();
        return;
    }
    }
    string resp = TcpClient->ExchangeMsg("TESTCONNECTION");
    if (resp == "OK") {
    resp = TcpClient->ExchangeMsg("INITGRAPHICS");
    if (resp != "OK") Error("InitGraphics error: " + resp);
    resp = TcpClient->ExchangeMsg("SETCOORDINATESYSTEM " + CoordSystem);
    }
    else {
    Error("Server connection error on initialization:\n" + resp);
    }
}

void StartServer()
{
/*
 * Placeholder until we can do something better!
 * Ideally we would start the server automatically,
 * but it is not immediately obvious how to implment this in
 * a way that would work across various *nix and Windows systems.
 */
    cout << "Error: please start the server" << endl;
}

void MovePen(double x, double y)
{
    if (TcpClient == NULL) Error("Graphics not initialized");
    stringstream cmd;
    cmd << "MOVEPEN " << x << " " << y;
    string resp = TcpClient->ExchangeMsg(cmd.str());
    if (resp != "OK") Error(cmd.str() + ": " + resp);
}

void DrawLine(double dx, double dy)
{
    if (TcpClient == NULL) Error("Graphics not initialized");
    stringstream cmd;
    cmd << "DRAWLINE " << dx << " " << dy;
    string resp = TcpClient->ExchangeMsg(cmd.str());
    if (resp != "OK") Error(cmd.str() + ": " + resp);
}

void DrawArc(double r, double start, double sweep)
{
    if (TcpClient == NULL) Error("Graphics not initialized");
    stringstream cmd;
    cmd << "DRAWARC " << r << " " << start << " " << sweep;
    string resp = TcpClient->ExchangeMsg(cmd.str());
    if (resp != "OK") Error(cmd.str() + ": " + resp);
}

double GetWindowWidth()
{
    if (TcpClient == NULL) Error("Graphics not initialized");
    string resp = TcpClient->ExchangeMsg("GETWINDOWWIDTH");
    double val;
    try { val = StringToReal(resp); }
    catch (ErrorException e) { Error("GetWindowWidth: " + resp); }
    return val;
}

double GetWindowHeight()
{
    if (TcpClient == NULL) Error("Graphics not initialized");
    string resp = TcpClient->ExchangeMsg("GETWINDOWHEIGHT");
    double val;
    try { val = StringToReal(resp); }
    catch (ErrorException e) { Error("GetWindowHeight: " + resp); }
    return val;
}

double GetCurrentX()
{
    if (TcpClient == NULL) Error("Graphics not initialized");
    string resp = TcpClient->ExchangeMsg("GETCURRENTX");
    double val;
    try { val = StringToReal(resp); }
    catch (ErrorException e) { Error("GetCurrentX: " + resp); }
    return val;
}

double GetCurrentY()
{
    if (TcpClient == NULL) Error("Graphics not initialized");
    string resp = TcpClient->ExchangeMsg("GETCURRENTY");
    double val;
    try { val = StringToReal(resp); }
    catch (ErrorException e) { Error("GetCurrentY: " + resp); }
    return val;
}


/* Section 2 -- Elliptical arcs */

/*
 * Function: DrawEllipticalArc
 * Usage: DrawEllipticalArc(rx, ry, start, sweep);
 * -----------------------------------------------
 * This procedure draws an elliptical arc.  It is exactly
 * the same in its operation as DrawArc in the graphics.h
 * interface, except that the radius is different along the
 * two axes.
 */

void DrawEllipticalArc(double rx, double ry,
                       double start, double sweep);

/* Section 3 -- Graphical regions*/

/*
 * Functions: StartFilledRegion, EndFilledRegion
 * Usage: StartFilledRegion(density);
 *        . . . other calls . . .
 *        EndFilledRegion();
 * ------------------------------
 * These calls make it possible to draw filled shapes on the
 * display.  After calling StartFilledRegion, any calls to
 * DrawLine and DrawArc are used to create a shape definition
 * and do not appear on the screen until EndFilledRegion is
 * called.  The lines and arcs must be consecutive, in the
 * sense that each new element must start where the last
 * one ended.  MovePen calls may occur at the beginning
 * or the end of the region, but not in the interior. When
 * EndFilledRegion is called, the entire region appears on the
 * screen, with its interior filled in.  The density parameter
 * is a number between 0 and 1 and indicates how the dot density
 * to be used for the fill pattern.  If density is 1, the shape
 * will be filled in a solid color; if it is 0, the fill will be
 * invisible.  In between, the implementation will use a dot
 * pattern that colors some of the screen dots but not others.
 */

void StartFilledRegion(double density = 1.0);
void EndFilledRegion();

/* Section 4 -- String functions */

/*
 * Function: DrawTextString
 * Usage: DrawTextString(text);
 * ----------------------------
 * This function displays the string text at the current point
 * in the current font and size.  The current point is updated
 * so that the next DrawTextString command would continue from
 * the next character position.  The string may not include the
 * newline character.
 */

void DrawTextString(string text);

/*
 * Function: TextStringWidth
 * Usage: w = TextStringWidth(text);
 * ---------------------------------
 * This function returns the width of the text string if displayed
 * at the current font and size.
 */

double TextStringWidth(string text);

/*
 * Function: SetFont
 * Usage: SetFont(font);
 * ---------------------
 * This function sets a new font according to the font string,
 * which is case-independent.  Different systems support different
 * fonts, although common ones like "Times" and "Courier" are often
 * supported.  Initially, the font is set to "Default" which is
 * always supported, although the underlying font is system
 * dependent.  If the font name is unrecognized, no error is
 * generated, and the font remains unchanged.  If you need to
 * detect this condition, you can call GetFont to see if the
 * change took effect.  By not generating an error in this case,
 * programs become more portable.
 */

void SetFont(string font);

/*
 * Function: GetFont
 * Usage: font = GetFont();
 * ------------------------
 * This function returns the current font name as a string.
 */

string GetFont();

/*
 * Function: SetPointSize
 * Usage: SetPointSize(size);
 * --------------------------
 * This function sets a new point size.  If the point size is
 * not supported for a particular font, the closest existing
 * size is selected.
 */

void SetPointSize(int size);

/*
 * Function: GetPointSize
 * Usage: size = GetPointSize();
 * -----------------------------
 * This function returns the current point size.
 */

int GetPointSize();

/*
 * Text style constants
 * --------------------
 * The constants Bold and Italic are used in the SetStyle
 * command to specify the desired text style.  They may also
 * be used in combination by adding these constants together,
 * as in Bold + Italic.  The constant Normal indicates the
 * default style.
 */

#define Normal  0
#define Bold    1
#define Italic  2

/*
 * Function: SetStyle
 * Usage: SetStyle(style);
 * -----------------------
 * This function establishes the current style properties
 * for text based on the parameter style, which is an integer
 * representing the sum of any of the text style constants.
 */

void SetStyle(int style);

/*
 * Function: GetStyle
 * Usage: style = GetStyle();
 * --------------------------
 * This function returns the current style.
 */

int GetStyle();

/*
 * Functions: GetFontAscent, GetFontDescent, GetFontHeight
 * Usage: ascent = GetFontAscent();
 *        descent = GetFontDescent();
 *        height = GetFontHeight();
 * -------------------------------------------------------
 * These functions return properties of the current font that are
 * used to calculate how to position text vertically on the page.
 * The ascent of a font is the distance from the baseline to the
 * top of the largest character; the descent is the maximum
 * distance any character extends below the baseline.  The height
 * is the total distance between two lines of text, including the
 * interline space (which is called leading).
 *
 * Examples:
 *   To change the value of y so that it indicates the next text
 *   line, you need to execute
 *
 *        y -= GetFontHeight();
 *
 *   To center text vertically around the coordinate y, you need
 *   to start the pen at
 *
 *       y - GetFontAscent() / 2
 */

double GetFontAscent();
double GetFontDescent();
double GetFontHeight();

/* Section 5 -- Mouse support */

/*
 * Functions: GetMouseX, GetMouseY
 * Usage: x = GetMouseX();
 *        y = GetMouseY();
 * -------------------------------
 * These functions return the x and y coordinates of the mouse,
 * respectively.  The coordinate values are real numbers measured
 * in inches from the origin and therefore match the drawing
 * coordinates.
 */

double GetMouseX();
double GetMouseY();

/*
 * Functions: MouseButtonIsDown
 * Usage: if (MouseButtonIsDown()) . . .
 * -------------------------------------
 * This function returns true if the mouse button is currently
 * down.  For maximum compatibility among implementations, the
 * mouse is assumed to have one button.  If the mouse has more
 * than one button, this function returns true if any button
 * is down.
 */

bool MouseButtonIsDown();

/*
 * Functions: WaitForMouseDown, WaitForMouseUp
 * Usage: WaitForMouseDown();
 *        WaitForMouseUp();
 * -------------------------------------------
 * The WaitForMouseDown function waits until the mouse button
 * is pressed and then returns.  WaitForMouseUp waits for the
 * button to be released.
 */

void WaitForMouseDown();
void WaitForMouseUp();

/* Section 6 -- Color support */

/*
 * Function: SetPenColor
 * Usage: SetPenColor(color);
 * --------------------------
 * This function sets the color of the pen used for any drawing,
 * including lines, text, and filled regions.  The color is a
 * string, which will ordinarily be one of the following
 * predefined color names:
 *
 *    Black, Dark Gray, Gray, Light Gray, White,
 *    Red, Yellow, Green, Cyan, Blue, Magenta
 *
 * The first line corresponds to standard gray scales and the
 * second to the primary and secondary colors of light.  The
 * built-in set is limited to these colors because they are
 * likely to be the same on all hardware devices.  For finer
 * color control, you can use the DefineColor function to
 * create new color names as well.
 */

void SetPenColor(string color);

/*
 * Function: SetPenColorRGB
 * Usage: SetPenColorRGB(1.0, 0.5, 0.0);
 * -------------------------------------
 * This function sets the color of the pen used for any drawing,
 * including lines, text, and filled regions.  The color is
 * specified by supplying intensity levels for the colors red, green,
 * and blue, which are the primary colors of light.  The
 * color values are provided as real numbers between 0 and 1,
 * indicating the intensity of that color.  This version is
 * useful when you don't need to keep the color around under a
 * defined name (for that, use DefineColor below).
 */

void SetPenColorRGB(double red, double green, double blue);

/*
 * Function: GetPenColor
 * Usage: color = GetPenColor();
 * -----------------------------
 * This function returns the current pen color as a string.
 */

string GetPenColor();

/*
 * Function: DefineColor
 * Usage: DefineColor(name, red, green, blue);
 * -------------------------------------------
 * This function allows the client to define a new color name
 * by supplying intensity levels for the colors red, green,
 * and blue, which are the primary colors of light.  The
 * color values are provided as real numbers between 0 and 1,
 * indicating the intensity of that color.  For example,
 * the predefined color Magenta has full intensity red and
 * blue but no green and is therefore defined as:
 *
 *      DefineColor("Magenta", 1, 0, 1);
 *
 * DefineColor allows you to create intermediate colors on
 * many displays, although the results vary significantly
 * depending on the hardware.  For example, the following
 * usually gives a reasonable approximation of brown:
 *
 *      DefineColor("Brown", .35, .20, .05);
 */

void DefineColor(string name,
                 double red, double green, double blue);

/* Section 7 -- Pictures */

/*
 * Function: DrawNamedPicture
 * Usage: DrawNamedPicture("bird.jpg");
 * ------------------------------------
 * This function looks for a image file with the
 * specified name in the "Pictures" subdirectory of the
 * project. It displays this image in the graphics window
 * so that the lower left corner of the image appears
 * at the current point.  The function generates an error
 * if the named picture cannot be found.  Note that,
 * although the interface presented here is the same for
 * all systems, the format used for the resource itself
 * may not be supported across all platforms. The ones that
 * are guaranteed to work are bitmaps (.bmp), GIFs (.gif),
 * and JPEGs (.jpg.) Others may work, but those are the only
 * ones that are guaranteed.
 */

void DrawNamedPicture(string name);

/*
 * Functions: GetPictureWidth, GetPictureHeight
 * Usage: w = GetPictureWidth("ball.gif");
 *        h = GetPictureHeight("ball.gif");
 * ----------------------------------------
 * These functions return the width and height (in inches)
 * of the named picture, as described in the comments
 * for DrawNamedPicture.
 */

double GetPictureWidth(string name);
double GetPictureHeight(string name);

/* Section 8 -- Miscellaneous functions */

/*
 * Function: SetCoordinateSystem
 * Usage: SetCoordinateSystem("cartesian");
 *        SetCoordinateSystem("screen");
 * ----------------------------------------
 * Sets the coordinate system used by the graphics library.
 * The argument to SetCoordinateSystem is either the string
 * "cartesian", which specifies a classical coordinate system
 * in which the origin is in the lower left and coordinates are
 * measured in pixels, or "screen", which specifies a more
 * contemporary screen-based coordinate system in which the
 * origin is in the upper left and coordinates are measured
 * in pixels.  The strings are considered without regard to
 * case.  Unlike the other functions in the library, this call
 * must be made before the call to InitGraphics.
 */
void SetCoordinateSystem(string system);

/*
 * Function: GetCoordinateSystem
 * Usage: mode = GetCoordinateSystem();
 * ------------------------------------
 * Returns the coordinate system in effect for the graphics
 * library, which is either "cartesian" or "screen".
 */
string GetCoordinateSystem();

/*
 * Function: SetEraseMode
 * Usage: SetEraseMode(true);
 *        SetEraseMode(false);
 * ---------------------------
 * The SetEraseMode function sets the value of the internal
 * erasing flag.  Setting this flag is similar to setting the
 * color to "White" in its effect but does not affect the
 * current color setting.  When erase mode is set to false,
 * normal drawing is restored, using the current color.
 */

void SetEraseMode(bool mode);

/*
 * Function: GetEraseMode
 * Usage: mode = GetEraseMode();
 * -----------------------------
 * This function returns the current state of the erase mode flag.
 */

bool GetEraseMode();

/*
 * Function: SetWindowTitle
 * Usage: SetWindowTitle(title);
 * -----------------------------
 * This function sets the title of the graphics window, if such
 * an operation is possible on the display.  If it is not possible
 * for a particular implementation, the call is simply ignored.
 * This function may be called prior to the InitGraphics call to
 * set the initial name of the window.
 */

void SetWindowTitle(string title);

/*
 * Function: GetWindowTitle
 * Usage: title = GetWindowTitle();
 * --------------------------------
 * This function returns the title of the graphics window.  If the
 * implementation does not support titles, this call returns the
 * empty string.
 */

string GetWindowTitle();

/*
 * Function: UpdateDisplay
 * Usage: UpdateDisplay();
 * -----------------------
 * This function initiates an immediate update of the graphics
 * window and is necessary for animation.  Ordinarily, the
 * graphics window is only updated when the program waits for
 * user input.
 */

void UpdateDisplay();

/*
 * Function: Pause
 * Usage: Pause(seconds);
 * ----------------------
 * The Pause function updates the graphics window and then
 * pauses for the indicated number of seconds.  This function
 * is useful for animation where the motion would otherwise
 * be too fast.
 */

void Pause(double seconds);

/*
 * Function: ExitGraphics
 * Usage: ExitGraphics();
 * ----------------------
 * The ExitGraphics function closes the graphics window and
 * exits from the application without waiting for any additional
 * user interaction.
 */

void ExitGraphics();

/*
 * Functions: SaveGraphicsState, RestoreGraphicsState
 * Usage: SaveGraphicsState();
 *        . . . graphical operations . . .
 *        RestoreGraphicsState();
 * ---------------------------------------------------
 * The SaveGraphicsState function saves the current graphics
 * state (the current pen position, the font, the point size,
 * and the erase mode flag) internally, so that they can be
 * restored by the next RestoreGraphicsState call.  These two
 * functions must be used in pairs but may be nested to any depth.
 */

void SaveGraphicsState();
void RestoreGraphicsState();

/*
 * Functions: GetFullScreenWidth, GetFullScreenHeight
 * Usage: width = GetFullScreenWidth();
 *        height = GetFullScreenHeight();
 * --------------------------------------
 * These functions return the height and width of the entire
 * display screen, not the graphics window.  Their only
 * significant use is for applications that need to adjust
 * the size of the graphics window based on available screen
 * space.  These functions may be called before InitGraphics
 * has been called.
 */

double GetFullScreenWidth();
double GetFullScreenHeight();

/*
 * Functions: SetWindowSize
 * Usage: SetWindowSize(width, height);
 * ------------------------------------
 * This function sets the window size to the indicated dimensions,
 * if possible.  This function should be called before the graphics
 * window is created by InitGraphics.  Attempts to change the size
 * of an existing window are ignored by most implementations.  This
 * function should be used sparingly because it reduces the
 * portability of applications, particularly if the client
 * requests more space than is available on the screen.
 */

void SetWindowSize(double width, double height);

/*
 * Functions: GetXResolution, GetYResolution
 * Usage: xres = GetXResolution();
 *        yres = GetYResolution();
 * -----------------------------------------
 * These functions return the number of pixels per inch along
 * each of the coordinate directions and are useful for applications
 * in which it is important for short distances to be represented
 * uniformly in terms of dot spacing.  Even though the x and y
 * resolutions are the same for most displays, clients should
 * not rely on this property.
 *
 * Note: Lines in the graphics library are one pixel unit wide and
 * have a length that is always one pixel longer than you might
 * expect.  For example, the function call
 *
 *     DrawLine(2 / GetXResolution(), 0);
 *
 * draws a line from the current point to the point two pixels
 * further right, which results in a line of three pixels.
 */

double GetXResolution();
double GetYResolution();

//#endif
//#include "extgraph.h"
//#include "simpio.h"
//#include "strutils.h"
//#include "genlib.h"
//#include "graphicsclient.h"
#include <string>
#include <sstream>
#include <ctime>

extern GraphicsClient *TcpClient;
extern string CoordSystem;
string NoSpaces(string str);
void ClientPause(double sec);
string GetPictureDirectory();

void DrawEllipticalArc(double rx, double ry,
                       double start, double sweep)
{
    if (TcpClient == NULL) Error("Graphics not initialized");
    stringstream cmd;
    cmd << "DRAWELLIPTICALARC " << rx << " " << ry << " "
    << start << " " << sweep;
    string resp = TcpClient->ExchangeMsg(cmd.str());
    if (resp != "OK") Error(cmd.str() + ": " + resp);
}

void StartFilledRegion(double density /*= 1.0*/)
{
    if (TcpClient == NULL) Error("Graphics not initialized");
    stringstream cmd;
    cmd << "STARTFILLEDREGION " << density;
    string resp = TcpClient->ExchangeMsg(cmd.str());
    if (resp != "OK") Error(cmd.str() + ": " + resp);
}

void EndFilledRegion()
{
    if (TcpClient == NULL) Error("Graphics not initialized");
    stringstream cmd;
    cmd << "ENDFILLEDREGION ";
    string resp = TcpClient->ExchangeMsg(cmd.str());
    if (resp != "OK") Error(cmd.str() + ": " + resp);
}

void DrawTextString(string text)
{
    if (TcpClient == NULL) Error("Graphics not initialized");
    stringstream cmd;
    cmd << "DRAWTEXTSTRING " << text;
    string resp = TcpClient->ExchangeMsg(cmd.str());
    if (resp != "OK") Error(cmd.str() + ": " + resp);
}

double TextStringWidth(string text)
{
    if (TcpClient == NULL) Error("Graphics not initialized");
    stringstream cmd;
    cmd << "TEXTSTRINGWIDTH " << text;
    string resp = TcpClient->ExchangeMsg(cmd.str());
    double val;
    try { val = StringToReal(resp); }
    catch (ErrorException e) { Error("TextStringWidth: " + resp); }
    return val;
}

void SetFont(string font)
{
    if (TcpClient == NULL) Error("Graphics not initialized");
    stringstream cmd;
    cmd << "SETFONT " << font;
    string resp = TcpClient->ExchangeMsg(cmd.str());
    if (resp != "OK") Error(cmd.str() + ": " + resp);
}

string GetFont()
{
    if (TcpClient == NULL) Error("Graphics not initialized");
    string resp = TcpClient->ExchangeMsg("GETFONT");
    return resp;
}

void SetPointSize(int size)
{
    if (TcpClient == NULL) Error("Graphics not initialized");
    stringstream cmd;
    cmd << "SETPOINTSIZE " << size;
    string resp = TcpClient->ExchangeMsg(cmd.str());
    if (resp != "OK") Error(cmd.str() + ": " + resp);
}

int GetPointSize()
{
    if (TcpClient == NULL) Error("Graphics not initialized");
    string resp = TcpClient->ExchangeMsg("GETPOINTSIZE");
    int val;
    try { val = StringToInteger(resp); }
    catch (ErrorException e) { Error("GetPointSize: " + resp); }
    return val;
}

void SetStyle(int style)
{
    if (TcpClient == NULL) Error("Graphics not initialized");
    stringstream cmd;
    cmd << "SETSTYLE " << style;
    string resp = TcpClient->ExchangeMsg(cmd.str());
    if (resp != "OK") Error(cmd.str() + ": " + resp);
}

int GetStyle()
{
    if (TcpClient == NULL) Error("Graphics not initialized");
    string resp = TcpClient->ExchangeMsg("GETSTYLE");
    double val;
    try { val = StringToReal(resp); }
    catch (ErrorException e) { Error("GetCurrentX: " + resp); }
    return val;
}

double GetFontAscent()
{
    if (TcpClient == NULL) Error("Graphics not initialized");
    string resp = TcpClient->ExchangeMsg("GETFONTASCENT");
    double val;
    try { val = StringToReal(resp); }
    catch (ErrorException e) { Error("GetFontAscent: " + resp); }
    return val;
}

double GetFontDescent()
{
    if (TcpClient == NULL) Error("Graphics not initialized");
    string resp = TcpClient->ExchangeMsg("GETFONTDESCENT");
    double val;
    try { val = StringToReal(resp); }
    catch (ErrorException e) { Error("GetFontDescent: " + resp); }
    return val;
}

double GetFontHeight()
{
    if (TcpClient == NULL) Error("Graphics not initialized");
    string resp = TcpClient->ExchangeMsg("GETFONTHEIGHT");
    double val;
    try { val = StringToReal(resp); }
    catch (ErrorException e) { Error("GetCurrentX: " + resp); }
    return val;
}

double GetMouseX()
{
    if (TcpClient == NULL) Error("Graphics not initialized");
    string resp = TcpClient->ExchangeMsg("GETMOUSEX");
    double val;
    try { val = StringToReal(resp); }
    catch (ErrorException e) { Error("GetMouseX: " + resp); }
    return val;
}

double GetMouseY()
{
    if (TcpClient == NULL) Error("Graphics not initialized");
    string resp = TcpClient->ExchangeMsg("GETMOUSEY");
    double val;
    try { val = StringToReal(resp); }
    catch (ErrorException e) { Error("GetMouseY: " + resp); }
    return val;
}

bool MouseButtonIsDown()
{
    if (TcpClient == NULL) Error("Graphics not initialized");
    string resp = TcpClient->ExchangeMsg("MOUSEBUTTONISDOWN");
    if (resp == "TRUE"){
        return true;
    }else return false;
    
    //if (resp == "FALSE") return false;

    // else problems
    //Error("MouseButtonIsDown: " + resp);
}

void WaitForMouseDown()
{
    if (TcpClient == NULL) Error("Graphics not initialized");
    while (true) {
    if (MouseButtonIsDown()) return;
    }
}

void WaitForMouseUp()
{
    if (TcpClient == NULL) Error("Graphics not initialized");
    while (true) {
    if (!MouseButtonIsDown()) return;
    }
}

void SetPenColor(string color)
{
    if (TcpClient == NULL) Error("Graphics not initialized");
    stringstream cmd;
    cmd << "SETPENCOLOR " << NoSpaces(color);
    string resp = TcpClient->ExchangeMsg(cmd.str());
    if (resp != "OK") Error(cmd.str() + ": " + resp);
}

void SetPenColorRGB(double red, double green, double blue)
{
    if (TcpClient == NULL) Error("Graphics not initialized");
    stringstream cmd;
    cmd << "SETPENCOLORRGB " << red << " " << green << " " << blue;
    string resp = TcpClient->ExchangeMsg(cmd.str());
    if (resp != "OK") Error(cmd.str() + ": " + resp);
}

string NoSpaces(string str)
{
    size_t found;
    while ((found = str.find(' ')) != string::npos) {
    str.erase(found,1);
    }
    return str;
}

string GetPenColor()
{
    if (TcpClient == NULL) Error("Graphics not initialized");
    string resp = TcpClient->ExchangeMsg("GETPENCOLOR");
    return resp;
}

void DefineColor(string name,
                 double red, double green, double blue)
{
    if (TcpClient == NULL) Error("Graphics not initialized");
    stringstream cmd;
    cmd << "DEFINECOLOR " << NoSpaces(name) << " "
    << red << " " << green << " " << blue;
    string resp = TcpClient->ExchangeMsg(cmd.str());
    if (resp != "OK") Error(cmd.str() + ": " + resp);
}

void DrawNamedPicture(string name)
/* We need to send an absolute file path, as the server has no idea
 * of the client's current directory.
 * Only the filename (no path) is stored with the width & height,
 * so GetPictureWidth/Height only need to send the filename.
 */
{
    if (TcpClient == NULL) Error("Graphics not initialized");
    string picDir = GetPictureDirectory();
    stringstream cmd;
    cmd << "DRAWNAMEDPICTURE " << picDir << name;
    string resp = TcpClient->ExchangeMsg(cmd.str());
    if (resp != "OK") Error(cmd.str() + ": " + resp);
}

string GetPictureDirectory()
{
    //TODO - find a portable way to set the path
    // getcwd() is POSIX compliant but won't work on Windows
    char the_path[256];
    getcwd(the_path, 255);
    string picDir = the_path;
    picDir += "/Pictures/";
    return picDir;
}

double GetPictureWidth(string name)
{
    if (TcpClient == NULL) Error("Graphics not initialized");
    stringstream cmd;
    cmd << "GETPICTUREWIDTH " << name;
    string resp = TcpClient->ExchangeMsg(cmd.str());
    double val;
    try { val = StringToReal(resp); }
    catch (ErrorException e) { Error("GetPictureWidth: " + resp); }
    return val;
}

double GetPictureHeight(string name)
{
    if (TcpClient == NULL) Error("Graphics not initialized");
    stringstream cmd;
    cmd << "GETPICTUREHEIGHT " << name;
    string resp = TcpClient->ExchangeMsg(cmd.str());
    double val;
    try { val = StringToReal(resp); }
    catch (ErrorException e) { Error("GetPictureHeight: " + resp); }
    return val;
}

void SetCoordinateSystem(string system)
{
    // Just store the value in a global variable for now
    // InitGraphics() will send it to the server later
    CoordSystem = system;
    
    // if (TcpClient == NULL) Error("Graphics not initialized");
    // stringstream cmd;
    // cmd << "SETCOORDINATESYSTEM " << system;
    // string resp = TcpClient->ExchangeMsg(cmd.str());
    // if (resp != "OK") Error(cmd.str() + ": " + resp);
}

string GetCoordinateSystem()
{
    if (TcpClient == NULL) Error("Graphics not initialized");
    string resp = TcpClient->ExchangeMsg("GETCOORDINATESYSTEM");
    return resp;
}

void SetEraseMode(bool mode)
{
    if (TcpClient == NULL) Error("Graphics not initialized");
    stringstream cmd;
    cmd << "SETERASEMODE ";
    if (mode) cmd << "TRUE";
    else cmd << "FALSE";
    string resp = TcpClient->ExchangeMsg(cmd.str());
    if (resp != "OK") Error(cmd.str() + ": " + resp);
}

bool GetEraseMode()
{
    if (TcpClient == NULL) Error("Graphics not initialized");
    string resp = TcpClient->ExchangeMsg("GETERASEMODE");
    if (resp == "TRUE"){
        return true;
    }else return false;
    //if (resp == "FALSE") return false;

    // else problems
    //Error("GetEraseMode: " + resp);
}

void SetWindowTitle(string title)
{
    if (TcpClient == NULL) Error("Graphics not initialized");
    stringstream cmd;
    cmd << "SETWINDOWTITLE " << title;
    string resp = TcpClient->ExchangeMsg(cmd.str());
    if (resp != "OK") Error(cmd.str() + ": " + resp);
}

string GetWindowTitle()
{
    if (TcpClient == NULL) Error("Graphics not initialized");
    string resp = TcpClient->ExchangeMsg("GETWINDOWTITLE");
    return resp;
}

void UpdateDisplay()
{
    if (TcpClient == NULL) Error("Graphics not initialized");
    stringstream cmd;
    cmd << "UPDATEDISPLAY ";
    string resp = TcpClient->ExchangeMsg(cmd.str());
    if (resp != "OK") Error(cmd.str() + ": " + resp);
}

void Pause(double seconds)
{
    if (TcpClient == NULL) Error("Graphics not initialized");
    stringstream cmd;
    int msec = seconds * 1000;
    cmd << "PAUSE " << msec;
    string resp = TcpClient->ExchangeMsg(cmd.str());
    // return value is milliseconds elapsed
}

void ExitGraphics()
{
    if (TcpClient == NULL) Error("Graphics not initialized");
    stringstream cmd;
    cmd << "EXITGRAPHICS ";
    string resp = TcpClient->ExchangeMsg(cmd.str());
    if (resp != "OK") Error(cmd.str() + ": " + resp);
}

void SaveGraphicsState()
{
    if (TcpClient == NULL) Error("Graphics not initialized");
    stringstream cmd;
    cmd << "SAVEGRAPHICSSTATE ";
    string resp = TcpClient->ExchangeMsg(cmd.str());
    if (resp != "OK") Error(cmd.str() + ": " + resp);
}

void RestoreGraphicsState()
{
    if (TcpClient == NULL) Error("Graphics not initialized");
    stringstream cmd;
    cmd << "RESTOREGRAPHICSSTATE ";
    string resp = TcpClient->ExchangeMsg(cmd.str());
    if (resp != "OK") Error(cmd.str() + ": " + resp);
}

double GetFullScreenWidth()
{
    if (TcpClient == NULL)
    Error("Sorry, in this version you need to run InitGraphics BEFORE GetFullScreenWidth/Height");
    string resp = TcpClient->ExchangeMsg("GETFULLSCREENWIDTH");
    double val;
    try { val = StringToReal(resp); }
    catch (ErrorException e) { Error("GetFulScreenWidth: " + resp); }
    return val;
}

double GetFullScreenHeight()
{
    if (TcpClient == NULL)
    Error("Sorry, in this version you need to run InitGraphics BEFORE GetFullScreenWidth/Height");
    string resp = TcpClient->ExchangeMsg("GETFULLSCREENHEIGHT");
    double val;
    try { val = StringToReal(resp); }
    catch (ErrorException e) { Error("GetFullScreenHeight: " + resp); }
    return val;
}

void SetWindowSize(double width, double height)
// This has the side effect of erasing the screen
{
    if (TcpClient == NULL) Error("Graphics not initialized");
    stringstream cmd;
    cmd << "SETWINDOWSIZE " << width << " " << height;
    string resp = TcpClient->ExchangeMsg(cmd.str());
    if (resp != "OK") Error(cmd.str() + ": " + resp);
}

void ClientPause(double sec)
// Note the contrast with Pause() - which tells the server to pause
// ClientPause() is local, blocking communication with the server
// May not be needed in the release version, but useful during debugging
{
    time_t start = time(NULL);
    while (difftime(time(NULL), start) < sec) {
    /* do nothing */
    }
}

double GetXResolution()
{
    if (TcpClient == NULL) Error("Graphics not initialized");
    string resp = TcpClient->ExchangeMsg("GETXRESOLUTION");
    double val;
    try { val = StringToReal(resp); }
    catch (ErrorException e) { Error("GetXResolution: " + resp); }
    return val;
}

double GetYResolution()
{
    if (TcpClient == NULL) Error("Graphics not initialized");
    string resp = TcpClient->ExchangeMsg("GETYRESOLUTION");
    double val;
    try { val = StringToReal(resp); }
    catch (ErrorException e) { Error("GetYResolution: " + resp); }
    return val;
}


Maze::Maze(int numRows, int numCols, bool hasWalls) : cells(numRows, numCols)
{
    for (int r = 0; r < numRows; r++)
        for (int c = 0; c < numCols; c++)
            for (int d = 0; d < NumDirs; d++)
                cells(r, c).walls[d] = hasWalls;
    configured = false;
}

int Maze::numRows()
{
    return cells.numRows();
}

int Maze::numCols()
{
    return cells.numCols();
}

bool Maze::pointInBounds(pointT p)
{
    return (p.row >= 0 && p.row < numRows() && p.col >=0 && p.col < numCols());
}


void Maze::draw()
{
    InitGraphics();    // this erases entire graphics window
    if (!configured) configureGraphics();
    for (int r = 0; r < cells.numRows(); r++) {
        for (int c = 0; c < cells.numCols(); c++) {
            pointT p = {r, c};
            drawWallsForCell(p);
        }
    }
    UpdateDisplay();
}

bool Maze::isWall(pointT p1, pointT p2)
{
    if (!pointInBounds(p1) || !pointInBounds(p2))
        Error("Point is not in bounds for maze");
    return cells(p1.row, p1.col).walls[neighborDir(p1, p2)];
}

void Maze::setWall(pointT p1, pointT p2, bool state)
{
    if (!pointInBounds(p1) || !pointInBounds(p2))
        Error("Point is not in bounds for maze");
    cells(p1.row, p1.col).walls[neighborDir(p1, p2)] = state;
    cells(p2.row, p2.col).walls[neighborDir(p2, p1)] = state;
    if (!configured) configureGraphics();
    drawWallsForCell(p1);
    UpdateDisplay();
}
void Maze::drawMark(pointT p, string color)
{
    if (!pointInBounds(p))
        Error("Point is not in bounds for maze");
    if (!configured) configureGraphics();
    double margin = cellSize*.3;
    double length = cellSize - 2*margin;
    SetPenColor(color);
    MovePen(originX + p.col*cellSize + margin, originY + p.row*cellSize + margin);
    DrawLine(length, length);
    MovePen(originX + p.col*cellSize + margin, originY + p.row*cellSize + cellSize - margin);
    DrawLine(length, -length);
    UpdateDisplay();
}


Maze::dirT Maze::neighborDir(pointT p1, pointT p2)
{
    if ((abs(p1.row-p2.row) + abs(p1.col-p2.col)) != 1)
        Error("Points are not neighbors");
    if (p1.row != p2.row)
        return (p1.row < p2.row ? North : South);
    else
        return (p1.col < p2.col ? East : West);
}

void Maze::drawWallsForCell(pointT p)
{
    MovePen(originX + p.col*cellSize, originY + p.row*cellSize);
    SetPenColor(cells(p.row, p.col).walls[South] ? "Black" : "White");
    DrawLine(cellSize, 0);
    SetPenColor(cells(p.row, p.col).walls[East] ? "Black" : "White");
    DrawLine(0, cellSize);
    SetPenColor(cells(p.row, p.col).walls[North] ? "Black" : "White");
    DrawLine(-cellSize, 0);
    SetPenColor(cells(p.row, p.col).walls[West] ? "Black" : "White");
    DrawLine(0, -cellSize);
}

void Maze::configureGraphics()
{
    cellSize = min(GetWindowWidth()/numCols(), GetWindowHeight()/numRows());
    originX = (GetWindowWidth() - numCols()*cellSize)/2;
    originY = (GetWindowHeight() - numRows()*cellSize)/2;
    configured = true;
}

/*
 * File : graphicsclient.cpp
 * Last modified September 2011 by Colin
 * ---------------------------------------------
 * Implements the client end of the Tcp connection,
 * and provides a simple way for graphics functions to
 * exchange messages with the server.
 */

//#include "graphicsclient.h"
//#include "ClientSocket.h"
//#include "SocketException.h"
//#include "genlib.h"

GraphicsClient::GraphicsClient(string host, int port)
{
    InitClient(host, port);
}

int GraphicsClient::InitClient(string host, int port)
{
    try {
        _sock = new ClientSocket(host, port);
    }
    catch (SocketException& e) {
        Error("Client exception: " + e.description());
    }
    return 0;
}

string GraphicsClient::ExchangeMsg(string cmd)
// All commands should provoke a reply (usually "OK")
{
    string reply;

    try {
        *_sock << cmd;
        *_sock >> reply;
    }
    catch ( SocketException& e ) {
        Error("Client exception: " + e.description());
    }
    return reply;
}

// Implementation of the ClientSocket class

//#include "ClientSocket.h"
//#include "SocketException.h"


ClientSocket::ClientSocket ( std::string host, int port )
{
  if ( ! Socket::create() )
    {
      throw SocketException ( "Could not create client socket." );
    }

  if ( ! Socket::connect ( host, port ) )
    {
      throw SocketException ( "Could not bind to port." );
    }
}


const ClientSocket& ClientSocket::operator << ( const std::string& s ) const
{
  if ( ! Socket::send ( s ) )
    {
      throw SocketException ( "Could not write to socket." );
    }
  return *this;
}


const ClientSocket& ClientSocket::operator >> ( std::string& s ) const
{
  if ( ! Socket::recv ( s ) )
    {
      throw SocketException ( "Could not read from socket." );
    }
  return *this;
}



/*****************************************Problem Four*******************************************/
char MostFrequentCharacter(ifstream & inputStream, int & numOccurrences);
void AskUserForInputFile(string prompt, ifstream & infile);
void MapTheCharacters(ifstream & inputStream, Map<int> & characterFrequency);
char FindTheMostFrequentCharacter(Map<int> characterFrequency, int & numOccurences);

void AssignmentTwo_ProblemFour(){
    ifstream inputStream;
    AskUserForInputFile("Please input the file name: ", inputStream);
    int numOccurences;
    cout<<"Most occurend character in the given file is "<<MostFrequentCharacter(inputStream, numOccurences)<<" and it occured "<<numOccurences<<" times."<<endl;
}

char MostFrequentCharacter(ifstream & inputStream, int & numOccurrences){
    Map<int> characterFrequency;
    MapTheCharacters(inputStream, characterFrequency);
    return FindTheMostFrequentCharacter(characterFrequency, numOccurrences);
}

void MapTheCharacters(ifstream & inputStream, Map<int> & characterFrequency){
    char ch;
    string charInString;
    while(true){
        ch = inputStream.get();
        if(inputStream.fail())break;
        if(isalpha(ch)){
            charInString = ch;
            charInString = ConvertToLowerCase(charInString);
            if(characterFrequency.containsKey(charInString)){
                characterFrequency[charInString] ++ ;
            }else{
                characterFrequency.add(charInString, 1);
            }
        }
    }
}

char FindTheMostFrequentCharacter(Map<int> characterFrequency, int & numOcurences){
    Map<int>::Iterator iter = characterFrequency.iterator();
    string temp, mostFrequent;
    for(int i = 0; iter.hasNext(); i++){
        temp = iter.next();
        if(i == 0) mostFrequent = temp;
        if(characterFrequency.getValue(temp) > characterFrequency.getValue(mostFrequent)){
            mostFrequent = temp;
        }
    }
    numOcurences = characterFrequency.getValue(mostFrequent);
    return mostFrequent[0];
}

/************************************Problem  Five******************************************/
void MakeGridOfCounts(Grid<bool> & bombLocations);
int boolToInt(bool input);
bool isSpaceOnLeft(Grid<int> grid,int row, int col);
bool isSpaceOnRight(Grid<int> grid,int row, int col);
bool isSpaceOnTop(Grid<int> grid,int row, int col);
bool isSpaceOnBottom(Grid<int> grid,int row, int col);

void AssignmentTwo_ProblemFive(){
    Grid<bool> bombLocations(6,6);
    for(int i = 0; i < bombLocations.numRows(); i++){
        for(int j = 0; j< bombLocations.numCols(); j++){
            bombLocations(i,j) = RandomChance(.5);
        }
    }
    
    cout<<"Printing the bombLocations Matrix"<<endl;
    for(int i = 0; i < bombLocations.numRows(); i++){
        for(int j = 0; j < bombLocations.numCols(); j++){
            cout<<bombLocations(i,j)<<" ";
        }
        cout<<endl;
    }
    MakeGridOfCounts(bombLocations);
}

void MakeGridOfCounts(Grid<bool> & bombLocations){
    Randomize();
    Grid<int> gridOfCount(bombLocations.numRows(), bombLocations.numCols());
    for(int i = 0; i < gridOfCount.numRows(); i++){
        for(int j = 0; j < gridOfCount.numCols(); j++){
            gridOfCount(i, j) = 0;
            if(isSpaceOnLeft(gridOfCount, i, j)){
                gridOfCount(i,j) += boolToInt(bombLocations(i - 1, j));
                if(isSpaceOnTop(gridOfCount, i, j)){
                    gridOfCount(i,j) += boolToInt(bombLocations(i - 1, j - 1));
                }
                if(isSpaceOnBottom(gridOfCount, i, j)){
                    gridOfCount(i,j) += boolToInt(bombLocations(i - 1, j + 1));
                }
            }
            if(isSpaceOnRight(gridOfCount, i, j)){
                gridOfCount(i,j) += boolToInt(bombLocations(i + 1, j));
                if(isSpaceOnTop(gridOfCount, i, j)){
                    gridOfCount(i,j) += boolToInt(bombLocations(i + 1, j - 1));
                }
                if(isSpaceOnBottom(gridOfCount, i, j)){
                    gridOfCount(i,j) += boolToInt(bombLocations(i + 1, j + 1));
                }
            }
            if(isSpaceOnTop(gridOfCount, i, j)){
                gridOfCount(i,j) += boolToInt(bombLocations(i, j - 1));
            }
            if(isSpaceOnBottom(gridOfCount, i, j)){
                gridOfCount(i,j) += boolToInt(bombLocations(i, j + 1));
            }
        }
    }
    
    cout<<"Printing the GridOfCount Matrix"<<endl;
    for(int i = 0; i < gridOfCount.numRows(); i++){
        for(int j = 0; j < gridOfCount.numCols(); j++){
            cout<<gridOfCount(i,j)<<" ";
        }
        cout<<endl;
    }
}

int boolToInt(bool input){
    return input? 1: 0;
}

bool isSpaceOnLeft(Grid<int> grid,int row, int col){
    return row > 0;
}

bool isSpaceOnRight(Grid<int> grid,int row, int col){
    return row < grid.numRows() - 1;
}

bool isSpaceOnTop(Grid<int> grid,int row, int col){
    return col > 0;
}

bool isSpaceOnBottom(Grid<int> grid,int row, int col){
    return col < grid.numCols() - 1;
}

/*************************PROGRAMMING ASSIGNMENT  2***************************/

void ProgrammingAssignmentTwo_ProblemOne();
void ProgrammingAssignmentTwo_ProblemTwo();

int Main(){
    
    int i;
    
    cout<<"Please choose the Programming Assignment Problem from below:"<<endl;
    cout<<"1. Random Writing."<<endl;
    cout<<"2. Reverse Queue"<<endl;
    cout<<"3. HTML Tags Checker"<<endl;
    cout<<"4. Character with highest frequency finder"<<endl;
    cout<<"5. Making Grid of counts"<<endl;
    cout<<"Choose the second Assignment problem number: ";
    
    i = GetInteger();
    
    switch(i){
        case 1:
            cout<<"Problem One:"<<endl;
            ProgrammingAssignmentTwo_ProblemOne();
            break;
        case 2:
            cout<<"Problem Two:"<<endl;
            ProgrammingAssignmentTwo_ProblemTwo();
            break;
        case 3:
            cout<<"Problem Three"<<endl;
            //AssignmentTwo_ProblemThree();
            break;
        case 4:
            cout<<"Problem Four"<<endl;
            AssignmentTwo_ProblemFour();
            break;
        case 5:
            cout<<"Problem Five"<<endl;
            AssignmentTwo_ProblemFive();
    }
    return 0;
}

/*****************Programming Assignment TWO Problem ONE********************/
void AskUserForInputFile(string prompt, ifstream & infile);
void SourceTextAnalysis(ifstream & infile, Map<Vector<int> > & sourceTextRecord, int  markovOrder);
void GenerateRandomText(Map<Vector<int> > & sourceTextRecord, int  markovOrder, int numberOfCharacters, string seed);
string PrintTheMap(Map<Vector<int> > & sourceTextRecord);

void ProgrammingAssignmentTwo_ProblemOne(){
    ifstream infile;
    AskUserForInputFile("Please input the file name to be read: ", infile);
    cout<<"Please input the Markov Order: ";
    int markovOrder = GetInteger();
    Map<Vector<int> > sourceTextRecord;
    SourceTextAnalysis(infile, sourceTextRecord, markovOrder);
    string seedMaxFrequency = PrintTheMap(sourceTextRecord);
    cout<<"Please entrer the number of charaters you want to generate: ";
    int numberOfCharacters = GetInteger();
    GenerateRandomText(sourceTextRecord, markovOrder, numberOfCharacters, seedMaxFrequency);
    
}

void AskUserForInputFile(string prompt, ifstream & infile){
    while(true){
        cout<<prompt;
        string filename = GetLine();
        filename = "/Users/rahulsachdeva/Documents/My Folder/Learn/Technical/Computer Science/Dev/Programming Abstraction/Programming Assignment Two/ProgAbstraction_ProgAssignTwo/ProgAbstraction_ProgAssignTwo/" + filename;
        infile.open(filename.c_str());
        if(!infile.fail()) break;
        cout<<"Unable to open "<<filename<<endl;
        infile.clear();
    }
}

void SourceTextAnalysis(ifstream & infile, Map<Vector<int> > & sourceTextRecord, int  markovOrder){
    
    string tempString;
    int temp;
    Vector<int> tempVector;
    while(true){
        temp = infile.get();
        tempString += temp;
        if(tempString.length() > markovOrder){
            if(sourceTextRecord.containsKey(tempString.substr(0, tempString.length() - 1))){
                tempVector = sourceTextRecord.getValue(tempString.substr(0, tempString.length() - 1));
                tempVector.add(temp);
                sourceTextRecord.add(tempString.substr(0, tempString.length() -1), tempVector);
                cout<<"Found One "<<tempString.substr(0, tempString.length() - 1)<<" "<<sourceTextRecord.get(tempString.substr(0, tempString.length() - 1)).size()<<endl;
                tempVector.clear();
            }else{
                tempVector.add(temp);
                sourceTextRecord.add(tempString.substr(0, tempString.length() -1), tempVector);
                tempVector.clear();
            }
            cout<<tempString.substr(0, tempString.length() - 1)<<" "<<(char)temp<<endl;
            tempString = tempString.substr(1);
        }
        if(temp == EOF) break;
    }
    if(tempString.length() < markovOrder)
        cout<<"Input text is not sufficient for "<< markovOrder<< "th markov order system."<<endl;
}

string PrintTheMap(Map<Vector<int> > & sourceTextRecord){
    cout<<endl<<endl;
    string temp, maxFrequency;
    Map<Vector<int> >::Iterator mapIter = sourceTextRecord.iterator();
    for(int i = 0; mapIter.hasNext(); i++){
        temp = mapIter.next();
        if(i == 0)maxFrequency = temp;
        if(sourceTextRecord.getValue(temp).size() > sourceTextRecord.get(maxFrequency).size()){
            maxFrequency = temp;
        }
        cout<<temp<<" ";
        Vector<int>::Iterator iter = sourceTextRecord.getValue(temp).iterator();
        while(iter.hasNext()){
            cout<<(char)iter.next()<<" ";
        }
        cout<<endl;
    }
    cout<<"maxFrequency "<<maxFrequency<<" "<<sourceTextRecord.get(maxFrequency).size()<<endl;
    return maxFrequency;
}

void GenerateRandomText(Map<Vector<int> > & sourceTextRecord, int  markovOrder, int numberOfCharacters, string seed){
    string currentSeed = seed, outputText = seed;
    char nextCharacter;
    for(int i = 0; i < numberOfCharacters; i++){
        nextCharacter  = (char)sourceTextRecord.get(currentSeed).getAt(RandomInteger(0, sourceTextRecord.get(currentSeed).size() - 1));
        outputText += nextCharacter;
        currentSeed = currentSeed.substr(1) + nextCharacter;
        if(nextCharacter == EOF) break;
    }
    cout<<outputText;
}
/**********************Programming Assignment TWO Problem TWO**************/

void GenerateThePerfectMaze(Maze & inputMaze);
pointT FindNeighbour(Maze & inputMaze, Set<pointT> & incPoints, pointT & currentPoint);

void ProgrammingAssignmentTwo_ProblemTwo(){
    Maze inputMaze = Maze(10, 20, true);
    //inputMaze.draw();
    GenerateThePerfectMaze(inputMaze);
    cout<<"Done"<<endl;
}

int comparePointT(pointT pointOne, pointT pointTwo){
    if(pointOne.row > pointTwo.row){
        return 1;
    }else if(pointOne.row == pointTwo.row && pointOne.col == pointTwo.col){
        return 0;
    }else return -1;
}


void GenerateThePerfectMaze(Maze & inputMaze){
    Set<pointT> incPoints(comparePointT);
    pointT currentPoint, neighbourPoint;
    currentPoint.row = RandomInteger(0, inputMaze.numRows());
    currentPoint.col = RandomInteger(0, inputMaze.numCols());
    while(incPoints.size() < inputMaze.numCols()*inputMaze.numRows()){
        neighbourPoint = FindNeighbour(inputMaze, incPoints, currentPoint);
        if(inputMaze.isWall(currentPoint, neighbourPoint)){
            inputMaze.setWall(currentPoint, neighbourPoint, false);
            cout<<"Done with setWall module"<<endl;
        }
        
        incPoints.add(neighbourPoint);
        currentPoint = neighbourPoint;
    }
}

pointT FindNeighbour(Maze & inputMaze, Set<pointT> & incPoints, pointT & currentPoint){
    pointT neighbourPoint;
    Vector<pointT> vectorOfNeighbours, vectorOfNonIncPoints;
    for(int i = -1; i < 2; i++){
        for(int j = -1; j < 2; j++){
            if(i + j != 0 && i != j){
                cout<<"FindNeighbour"<<endl;
                neighbourPoint.row = currentPoint.row + i;
                neighbourPoint.col = currentPoint.col + j;
                if(inputMaze.pointInBounds(neighbourPoint)){
                    vectorOfNeighbours.add(neighbourPoint);
                    if(! incPoints.contains(neighbourPoint)){
                        vectorOfNonIncPoints.add(neighbourPoint);
                    }
                }
            }
        }
    }
    if(vectorOfNonIncPoints.size() != 0)
        return vectorOfNonIncPoints[RandomInteger(0, vectorOfNonIncPoints.size() - 1)];
    else return vectorOfNeighbours[RandomInteger(0, vectorOfNeighbours.size() - 1)];
    
}
